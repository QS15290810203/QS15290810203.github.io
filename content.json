{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Tomcat环境变量配置步骤","slug":"win10系统Tomcat环境变量配置步骤","date":"2019-10-31T10:59:32.000Z","updated":"2019-10-31T14:54:14.986Z","comments":true,"path":"2019/10/31/win10系统Tomcat环境变量配置步骤/","link":"","permalink":"http://yoursite.com/2019/10/31/win10系统Tomcat环境变量配置步骤/","excerpt":"","text":"第一步在win10系统上，鼠标右键此电脑，选择属性，点击高级系统设置，然后点击环境变量，如下图所示：第二步环境变量配置界面之后，点击新建，如下图所示：第三步首先新建一个CATALINA_BASE环境变量，值为tomcat的安装路径，如下图所示：第四步点击确定之后，新建一个CATALINA_HOME的环境变量，值为tomcat安装路径，如下图所示：第五步点击确定之后，找到path变量，双击进去分别添加“%CATALINA_HOME%\\lib”和“%CATALINA_HOME%\\bin”，如下图所示：第六步配置好环境变量之后，连续点击确定保存，然后进去tomcat安装路径的bin目录，双击startup.bat，进行启动tomcat，如果这个时候出现闪退的情况，代表jre没有配置好，需要新建一个JRE_HOME环境变量，值是jre的安装路径，如下图所示：第七步双击startup.bat启动tomcat之后，我们在浏览器地址栏输入“http://localhost:8080/”，出现tomcat界面，代表环境变量配置成功，如下图所示：END","categories":[],"tags":[]},{"title":"2019-10-31JDK的创建步骤","slug":"JDK的创建步骤","date":"2019-10-31T10:25:16.000Z","updated":"2019-10-31T10:31:19.916Z","comments":true,"path":"2019/10/31/JDK的创建步骤/","link":"","permalink":"http://yoursite.com/2019/10/31/JDK的创建步骤/","excerpt":"","text":"JDK的创建步骤1打开浏览器，输入JDK搜索，根据搜索结果下载安装包安装应用 2先接受协议，再根据自己的电脑下载相应的JDK版本，默认安装就行了。 3配置环境变量。找到安装路径，默认安装的一般都是在这个路径下C:\\Program Files\\Java\\jdk1.8.0_77 4然后点击电脑开机键，打开控制面板 5然后点击系统安全，打开进入 6点击系统 7点击“高级系统设置” 8点击高级中的“环境变量” 9在下面的系统变量中点击“新建” 10新建JAVA_HOME、CLASSPATH这两个项，最后在path中添加上去就完成了 11新建CLASSPATH，变量值 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar，注意前面有个点的 12将这两个变量加到path里面，直接在后面添加 ;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin，注意前面要有个分号“;” 13变量操作界面点击确定关闭 14系统高级设置页面点击“确定”关闭 15两个变量配置好了，到时直接可以在控制台编译运行Java文件，运行cmd查看Java环境是否配好。 16输入javac，按回车键，出现下面这些说明编译环境配好了 17再输入java，按回车键，出现下面这些，说明运行环境也好了。 END","categories":[],"tags":[]},{"title":"python知识点总结","slug":"python知识点总结","date":"2019-10-31T09:46:49.000Z","updated":"2019-10-31T09:48:18.950Z","comments":true,"path":"2019/10/31/python知识点总结/","link":"","permalink":"http://yoursite.com/2019/10/31/python知识点总结/","excerpt":"","text":"1、Python的两种编程方式：交互式（随输随运行）和文件式（主要方式；批量运行出结果） 2、一切皆对象，每个对象由标识（id()）、类型（type()）和值（print()）标识。 3、Python采用基于值的内存管理,不同变量赋值为同一个值，ID一样，但是只适用范围在-5至256的整数和短字符串。 4、内置函数（BIF），68个，查看方式：dir(builtins)分类：数值数据类型：int,float,complex,bool,decimal,fractions序列数据类型：字符串（string）、列表（list）、元祖（tuple）、bytes、bytearray集合数据类型：set、frozenset字典数据类型：dict不可变的数据类型：数值Number、字符串String、元祖Tuple可变的数据类型：列表List、字典Dict、集合Set 5、二进制：0b/0B开头八进制：0o/0O开头十六进制;0x/0X开头 6、数值运算函数：abs(x)：绝对值 ；divmod(x,y)：商余 ；pow(x,y,z)：幂余（(x**y)%z） ；round(x,d)：四舍五入d位 ；max/min ； int(x) /float(x) /complex(x) 7、math库：常数：math.pi ；math.fabs(x)：绝对值 ；math.fmod(x,y)：x%y ；math.ceil(x)：向上取整，返回不小于x的最小整数 ；math.floor(x)：向下取整，返回不大于x的最大整数 ；math.modf(x)：返回x的小数和整数部分 ；math.trunc(x)：返回x的整数部分 8、浮点数类型：0.1 + 0.2不等于 0.3 ，浮点数有小尾数。看是否等于可以用round（）函数帮助去小尾数。 9、类型间混合运算：整数 -&gt; 浮点数 -&gt; 复数 10、布尔数据类型（bool）包含两个值-&gt;True（真–1）或假（False–0）。如果表达式的结果为数值类型的0、空字符串（“”）、空元祖（）、空列表[]、空字典{}，则其布尔值为false（假），否则为true（真）。 11、逻辑运算符：and、or、nota and b等于a if not a else b ； a or b 等于a if a else b。not一定会返回true或false；and和or不一定。 12、运算优先级（由高到低）**（指数）&gt; +x.-x（正负号）&gt; *./.%（乘。除。取余）&gt; +. -（加。减）&gt; &amp;(与）&gt; ^（或）&gt; \\（非）&gt;比较大小&gt; not（非）&gt; and（与）&gt;or（或）&gt; lambda表达式 13、序列型数据（1）序列的索引s[i]：如果索引下标越界，导致IndexError；如果索引下标不是整数，导致TypeError。（2）序列的切片（截取序列s的一部分）：顾头不顾尾。（3）序列的加：x + y：连接两个序列； 序列的乘（复制）：x * n：复制n次序列x ；（4）判断子串：x in s ：返回True/False ； s.count(x)：返回x在s中出现的次数 ； s.index(x,i,j)：返回x在s（范围[i,j]）中第一次出现的索引位置。（5）序列的排序：sorted(s, key=None,reverse=False)。reverse为false是为升序，为true时为倒序。返回结果为一个列表。（6）序列的拆封赋值：当变量个数和序列长度相等时，一一对应赋值。如a,b = (1,2)即a = 1,b = 2。不等则导致ValueError。或使用变量（将多个值作为整体赋给变量）或使用临时变量‘_’ 14、字符串类型 比较字符ASCII码值的大小：空格&lt;数字&lt;大写字母&lt;小写字母Unicode变字符：chr(u) ；字符变Unicode：ord(x)format（）方法的格式控制：（1）槽{序号}的使用（2）{参数序号：格式控制标记}，格式控制标记包括：填充、对齐（分别用&lt;、&gt;、^表示左、右和居中对齐）、宽度、精度、类型（b=二进制，c=Unicode,d=十进制，o=八进制，xX=十六进制）。（3）字符串的类型判断：str.isdigit()是否全为数字（0-9）；str.isalpha()是否全为字母；str.isal num()是否全为数字或字母；str.isspace()是否是空白（空格、制表符、换行符等）；str.isprintable()是否可打印（空格和没有东西是可以被打印的）；str.isidentifier()是否满足标识符定义规则（字母或下划线开头，只含数字、字母和下划线）（4）大小写转换：str.capitaiize()：转换为首字母大写，其余小写；str.title()各单词首字母大写。（5）对齐：居中str.center(长度，填充物) ；左对齐：ljust ；右对齐：rjust。填充：str.zfill(长度)相当于右对齐，前方补0。如果str前有正负号，则正负号也算长度，在正负号之后填充。移除：左右两边：str.strip(字符chars) ； 左边：str.lstrip() ；右边;rstrip（）（6）字符串的查找：find和indexstr.find(s):从左至右查找str中是否含s,有则返回第一次出现s的索引位置，否则返回-1str.index（x）：从左至右查找是否含有x，有则返回第一次出现的索引位置，没有则抛出ValueErrorstr.rfind()和str.rindex()就是从右至左查找。（7）字符串的替换：S.replace(old,new,count)。将S中的old替换为new，如果给定count，则只替换前count个old子串。（8）拆分/分割：S.split(分隔符sep,分割次数maxsplit), maxsplit = -1或不指定时，会从左向右搜索完整个字符串。S.rsplit()是从右往左。生成列表。S.partition(sep)，S.rpartition(sep)(从右往左搜索)。搜索S中的子串sep，并从第一个sep处分割，返回一个包含三个元素的元组 –&gt;（sep左边的部分，sep，sep右边的部分）。如果搜索不到sep，则返回中有两个元素为空，partition是后两个元素为空，rpartition是前两个为空。（9）连接组合：S.join（字符串对象）。 当对象为字符串字典时，结果是键的连接。 15、列表类型 列表list是可变对象，则对其增删改查不会改变其的id。除了list.copy().方法：（1）添加：list.appand(x)：将元素x添加到列表的尾部；list.extend(L)：将列表L中所有元素添加到列表的尾部；list.insert(index,x)：在列表指定位置index处添加元素x；（2）删除：list.remove(x)：删除列表中首次出现的元素x；list.pop(kediedai[index])：删除并返回指定位置的元素（可以理解为挖取出），list为空就抛IndexError异常；list.clear()：删除列表中所有元素，但保留列表对象。（3）排序：list.reverse()：倒序；list.sort()：排序（正或倒）；（4）其他：list.index(x)：返回值为x首次出现的下标；list.count(x)：返回x的出现总次数；list.copy() ：返回列表对象的浅拷贝。很厉害！！它可以改变列表的ID！浅拷贝——只拷贝一层。如果拷贝对象只有一层，那么同b = a[:]，两个变量相互独立的。但如果拷贝对象只有一层，就会有影响，会跟着改变。（详见例题）！！列表推导式：[新元素表达式 for 临时变量 in 可迭代对象 if 条件表达式] 16、集合类型集合中的元素没有顺序，且不重复。集合set是可变的，用大括号表示。但是{}表示空字典；set()表示空集合，用set（）创建集合时，会将元素一个一个拆开，如’hello’变成’h’,‘e’,‘l’,‘l’,‘o’。集合中元素要是固定数据类型：整数、浮点数、字符串、元组等。不可为可变的列表、字典、集合。利用集合过滤掉重复的元素。4种基本操作：交（&amp;）、并（|）、差（-）、补（^）S.add() ;S.clear() ;S.copy() ; S.remove() ;len(S) ;x (not)in S ;**S.pop()：随机返回S中的一个元素，如果S为空，产生KeyError.(区分list.pop([index]))特有的：S.discard(X)；如果x在S中，移除x，不在，不报错。主要三大用途：成员关系测试、元素去重、删除数据项。 17、字典类型（映射）{建（key）：值（value）}。键不能重复，且是不可变对象。值可变。元素没有顺序。创建一个空字典：dict（） ；创建字典：dict(‘a’=1,‘b’=2)/dict(‘a’:1,‘b’:2)/dict((‘a’,1),(‘b’,2))查找值：Dict[key] ；修改键值：dict[key] = new_value ；增添新键值：dict[new_key] = new_value .D.keys()：返回所有键的列表,如dict_keys([‘a’, ‘b’, ‘c’])；D.values()：返回所有值的列表,如dict_values([1, 2, 3])；D.items()：返回所有的键值对的列表,如dict_items([(‘a’, 1), (‘b’, 2), (‘c’, 3)])；D.get(key,v)：键存在则返回相应值，否则返回None（自定义了v时，返回v的内容）;D.pop(key.value)：键存在则返回相应值，同时删除键值对，否则返回None；D.popitem()：随机取出一个键值对，以元组（key，value）形式返回；D.setdefault(k,v)：如果键k存在，返回对应值，否则添加项目k = v,v默认为None；D.update(dict)：更新或添加键值对；D.clear()：删除所有的键值对；del.D[key]：删除key对应的键值对。如果key不存在，则抛出KeyError。 遍历：for 变量名 in 字典名： 18、可变与不可变（关于值）可变：列表（有序）、集合（无序）、字典（无序）不可变：字符串（有序）、元组（有序）Python是基于值的内存管理方式，举例：a=[1,2,3],b=[1,2,3]，a==b成立。 但是id(a)与id(b)不相等，id(a[0])==id(b[0])成立。总结就是关乎值的就相等什么叫可变？即值是可变的，但id是固定不变的。例如可变的列表，修改列表L中的一个元素的值，列表L的id是不变的。不管是可变还是不可变的序列类型：（1）分片必定产生新的序列；（2）“+”号在等号右边（L=L+[i]），必定产生新的序列。然后将新的序列地址赋予给等号左边的变量。（每一次执行时都会将原列表复制一次，L指向新列表，并在新列表中加入新元素）对三种列表添加方法进行总结：（1）L=L+[i]在每一次执行时都会将原列表复制一次，L指向新列表，并在新列表中加入新元素。（2）L.append(i)只是将新元素直接添加到原列表中，不会产生新列表。（3）L+=[i]的执行效果和L.append(i)类似，也是在原列表中直接添加元素，不会复制原列表。b = a VS b = a[:]b = a时，b就是跟着a变化，并且a与b的id一样。b = a[:]时，b与a是独立的整体，id就不同，只不过指向了同一个值。对a做修改（增删改查），对b没有影响。 19、程序的三种基本结构：顺序结构、·分支结构（if-else、elif）、·循环结构（遍历：for…in、条件：while。循环控制：break/continue）。异常值处理：try-except。二分支结构简单语法：表达式1 if 条件 else 表达式2循环结构分遍历循环（for）和无限循环（while）：遍历循环：for 循环变量 in 遍历结构：语句块（从遍历结构逐一提取元素，放在循环变量中，对每一个提取出的元素执行一次语句块。）无限循环：while 条件：语句块。判断条件为True就一直循环，为false时魂环结束，执行与while同级别缩进的后续语句。break用于结束当前循环，如果有两层循环，break用于跳出最内层for或while循环，脱离该循环后程序从循环后代码继续执行；continue用来结束当前循环的当次循环过程，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。当有输入要求时，可运用异常值处理try：except： 20、函数（1）形参与实参：定义函数时的参数是形参，调用函数时的参数是实参。（2）参数传递的方法：位置参数、默认值参数、关键字参数、命名关键字参数。。。位置参数：按位置顺序传递参数值，位置参数要在所有参数之前，是第一个参数；关键字参数：关键字参数就是在调用函数，传入实参时指定形参的变量名。关键字不用遵守位置的对应关系。参数之间的顺序可以任意调整。关键字传递可以和位置传递混用。但位置参数要在关键字参数之前。举例：def hello(name,age = 11,gender = ‘F’):（age = 11,gender = ‘F’就是关键字参数）。举例：def hello(name,age = 11,gender = ‘F’):（age = 11,gender = ‘F’就是关键字参数）默认值参数：定义参数时已经给定值，一般参数为不可变对象，（如果为可变的空列表，可用于装位置参数）；可变数量参数：args、kw带有星号的可变参数只能出现在参数列表的后面。调用时，参数被当作元组类型传递到函数中。(如： def func(*args): -&gt; func(10,20))带双星号（）的参数，在使用时必须指定参数值，使用key=value这种形式，只能出现在参数列表的最后。调用时，kw后的那些参数被当作字典类型传递到函数中。（如：def func(kw): -&gt; func(a=10,b=20)）强制命名参数：参数带星号或者就是一个星号（def f(*c或,a,b,c)），强制命令参数c 的含义是它后面的参数必须用实名调用，即必须用 a = … , b = … 来调用，不能只写值。Python中只有函数，函数是有返回值的，*如果没有return，默认返回None。**return返回多个值时，多个值以元组形式保存。 21、比较（1）list.sort（）与全局sorted（）list.sort(key = None,reverse = False)是列表内置排序方法。但其返回值为None（x.sort()的结果、print（x.sort()）、x = x.sort()后x的结果都是None）,只有当文字说“执行语句x.sort（），x的值为”，x.sort（）作用的结果，需要通过打印被作用的列表才可以查看结果。true是倒序，false是正序。sorted（）：Python内置方法。返回新的列表。（2）list.reverse（）和reversed（）list.reverse()返回的是None，其作用的结果，需要通过打印被作用的列表才可以查看结果。reversed()：内置方法。经过reversed（）作用之后，返回的是一个吧序列值经过倒序的迭代器，所以，需要通过遍历或list、tuple或next（）方法，才能获得作用后的值。（3）字符串的查找：find和indexstr.find(s):从左至右查找str中是否含s,有则返回第一次出现s的索引位置，否则返回-1str.index（x）：从左至右查找是否含有x，有则返回第一次出现的索引位置，没有则抛出ValueErrorstr.rfind()和str.rindex()就是从右至左查找。 22、函数变量的作用域（1）局部变量、全局变量、globalglobal：用于在函数中直接修改全局变量的值。（2）内嵌函数内嵌函数的作用域仅限其所在的函数体内。如果要在内部函数中修改外部函数中的局部变量的值，使用nonlocal关键字。 END","categories":[],"tags":[]},{"title":"JAVA汉诺塔问题","slug":"JAVA汉诺塔问题","date":"2019-10-31T03:49:56.000Z","updated":"2019-10-31T03:51:52.768Z","comments":true,"path":"2019/10/31/JAVA汉诺塔问题/","link":"","permalink":"http://yoursite.com/2019/10/31/JAVA汉诺塔问题/","excerpt":"","text":"汉诺塔问题：有三根柱子A,B,C，其中A上面有n个圆盘，从上至下圆盘逐渐增大，每次只能移动一个圆盘，并且规定大的圆盘不能叠放在小的圆盘上面，现在想要把A上面的n个圆盘全部都移动到C上面，输出移动的总步数以及移动的过程分析：//先求出移动的总步数1，假设g（n）表示n个圆盘时的移动总的步数，当n=1时，g(1)=1;2.现在可以把g(n)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B上面，相当于将n-1个圆盘从A移动到C，因此需要g(n-1)步； 2&gt;然后将剩下的最大的圆盘从A移动到C，需要1步； 3&gt;最后再将n-1个圆盘从B通过A移动到C上面，相当于将n-1个圆盘从A移动到C，因此也需要g(n-1)步； 因此可以得出递归关系式：g(n) = 2*g(n-1)+1;//现在我们在来求出移动的过程1.假设hm(m,a,b,c)表示将m个圆盘从a通过b移动到c的过程，假设mv(a,c)输出一次a到c的过程，即print a–&gt;c2.初始化hm，当m=1时，hm(1,a,b,c)=mv(a,c);3.可以把hm(m,a,b,c)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B，此时b和c进行互换，也就是 hm(m-1,a,c,b); 2&gt;然后将剩下的最大的圆盘从A移动到C，也就是hm(1,a,b,c); 3&gt;最后将n-1个圆盘从B通过A移动到C，此时b和a进行交换，也就是 hm(m-1,b,a,c); 最终得到过程的递归关系式：hm(m,a,b,c) = hm(m-1,a,c,b)+1+hm(m-1,b,a,c); 代码：public class test{public static void main(String[] args){ Scanner in = new Scanner(System.in); int n = in.nextInt(); test t = new test(); //获取总的步数 System.out.println(“需要移动的总步数为:” +t.getSum(n)); //获取移动的过程 t.hm(n,’a’,’b’,’c’); } //获取总步数 public int getSum(int n){ if(n == 1) return 1; return 2 * getSum(n-1) +1 ; } //获取移动的过程 public void hm(int m,char a,char b,char c){ if(m == 1) move(a,c); hm(m-1,a,c,b); move(a,c); hm(m-1,b,a,c); } //输出一次移动的过程 public void move(char a,char c){ System.out.print(a + “–&gt;” + c + “ “); } }","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2019-10-13T10:01:23.000Z","updated":"2019-10-13T10:02:53.057Z","comments":true,"path":"2019/10/13/第一篇博客/","link":"","permalink":"http://yoursite.com/2019/10/13/第一篇博客/","excerpt":"","text":"Javaoop总结1.类与对象 抽象的，泛指的，是指从某一类具有相同属性和方法的对象中抽取出来 class代表类 类的作用；实例化对象，方法，工具类 类中分两大块：属性（成员变量） 方法（成员方法） 类如何实例化对象？ new Person p = new Person(); p.name = “张三”; p.sex = “男”; p：对象名 Person p1 = new Person();2. 属性与方法 方法的调用：对象名.方法名 匿名对象调用方法：new 类().方法名 new Person().getA(); int c = new Person().getD(10, 20); //实参 System.out.println(c);3.static static 静态，static用来修饰属性、方法 用static修饰属性：共有的属性——实例化出来的对象，用static修饰的具有相同的值。 用static修饰方法：能通过类名直接调用 4.封装, oopd三大特征之一； 属性私有化，公开setter和getter方法； 单例模式 只能实例化一次； 实现单例式的三个步骤：第一：私有化构造方法 private 类名（）{ } 第二：公开一个代理方法 private static 类名 方法名（）{ 类名 d=null； if（count&lt;1）{ d=new 类名（）； count++; } return d; } 第三：私有化一个静态属性，用来统计new的个数 private static int count=0; 5.继承,oop三大特征之一 继承 会让两个类产生一种关系 父类-子类 父类：从子类中抽取出共同的属性和共同的方法，放到父类中， 然后让子类继承父类，那子类就具有父类的属性和方法 继承的关键词：extends 类的继承格式 class 父类 { } class 子类 extends 父类 { } (1)父类中私有的属性和方法，子类是不能继承的 (2)父类的构造方法，子类是不能继承的 (3)父类是跨包的，除public以外的都不能被继承super 子类用来访问父类的方法或者属性 super.方法 super.属性 super()只能放在子类的构造方法中，并且只能放在第一行 重写 子类重写父类的方法； 方法名 +快捷键 多态,oop三大特征之一 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性多态存在的三个必要条件继承重写父类引用指向子类对象向上转型子类向父类的转换&lt;父类型&gt; &lt;引用变量名&gt;=new&lt;子类型&gt;;向下转型父类型转换为子类型&lt;子类型&gt;&lt;引用变量名&gt;=(&lt;子类型&gt;）&lt;父类型的引用变量&gt;; 抽象 (1)抽象 abstract abstract能修饰什么？类，方法(2) 用abstract修饰类叫抽象类 特点：抽象类不能被实例化，但能被继承 (3)用abstract修饰的方法叫抽象方法 特点：1.抽象方法没有方法体 2.抽象方法必须放在抽象类中，抽象类中的方法不一定是抽象方法 3.抽象类被子类继承后，那么子类要重写父类中的抽象方法，除非子类也是抽象类 访问权限private (私有的) 默认 (友好的) protected (受保护的) public (公共的) 9.final (1)final修饰类中的属性或者变量 无论属性是基本类型还是引用类型，final所起的作用都是变量里面存放的“值”不能变。 (2)final修饰类中的方法 作用：可以被继承，但继承后不能被重写。 (3)final修饰类 作用：类不可以被继承。 10.接口（重点） 创建接口类 public interface 接口的声明语法格式 interface 接口名称 extends 其他的接口名 { // 声明变量 // 抽象方法 } 接口关键字： interface 类要实现接口：implements class 类名 extends 父类名 implements 接口，接口，…{ //类成员 } 接口中的方法全是抽象方法 接口中的方法全部要公开public 接口不能被实例化 接口可以被多实现 接口中的属性全部是静态常量","categories":[],"tags":[]},{"title":"Readers are welcome to browse","slug":"Readers-are-welcome-to-browse","date":"2019-10-10T10:19:43.000Z","updated":"2019-10-10T10:20:41.888Z","comments":true,"path":"2019/10/10/Readers-are-welcome-to-browse/","link":"","permalink":"http://yoursite.com/2019/10/10/Readers-are-welcome-to-browse/","excerpt":"","text":"public class HelloWorld { /* 第一个Java程序 * 它将打印字符串 Hello World */ public static void main(String []args) { System.out.println(“Hello World”); // 打印 Hello World }}","categories":[],"tags":[]},{"title":"post title with whitespace","slug":"post-title-with-whitespace","date":"2019-10-10T07:03:54.000Z","updated":"2019-10-10T09:56:19.604Z","comments":true,"path":"2019/10/10/post-title-with-whitespace/","link":"","permalink":"http://yoursite.com/2019/10/10/post-title-with-whitespace/","excerpt":"","text":"python","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-09T13:21:42.052Z","updated":"2019-10-09T13:21:42.052Z","comments":true,"path":"2019/10/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}