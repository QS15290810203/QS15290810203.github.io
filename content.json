{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JAVA基础知识","slug":"JAVA基础知识","date":"2019-11-03T02:39:49.000Z","updated":"2019-11-03T02:41:16.970Z","comments":true,"path":"2019/11/03/JAVA基础知识/","link":"","permalink":"http://yoursite.com/2019/11/03/JAVA基础知识/","excerpt":"","text":"java基础知识概述：1991 年Sun公司的James Gosling（詹姆斯·高斯林）等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器； 1994年将Oak语言更名为Java； Java的三种技术架构: JAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发； JAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础； JAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序； 1，JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。 2，JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。 3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。 环境变量的配置：1）：永久配置方式：JAVA_HOME=%安装路径%\\Java\\jdk path=%JAVA_HOME%\\bin 2）：临时配置方式：set path=%path%;C:\\Program Files\\Java\\jdk\\bin 特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。 classpath的配置:1）：永久配置方式：classpath=.;c:;e:2）：临时配置方式：set classpath=.;c:;e:\\ 注意：在定义classpath环境变量时，需要注意的情况 如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件； 如果指定了classpath，那么会在指定的目录下查找要运行的类文件。 还会在当前目录找吗？两种情况： 1）：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。 2）：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。 一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。 4，javac命令和java命令做什么事情呢？ 要知道java是分两部分的：一个是编译，一个是运行。javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。java：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数. java语法基础：1，关键字：其实就是某种语言赋予了特殊含义的单词。保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。 2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；注意： 1），数字不可以开头。 2），不可以使用关键字。 3，常量：是在程序中的不会变化的数据。 4，变量：其实就是内存中的一个存储空间，用于存储常量数据。 作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。 特点：变量空间可以重复使用。 什么时候定义变量？只要是数据不确定的时候，就定义变量。 变量空间的开辟需要什么要素呢？ 1，这个空间要存储什么数据？数据类型。 2，这个空间叫什么名字啊？变量名称。 3，这个空间的第一次的数据是什么？ 变量的初始化值。 变量的作用域和生存期: 变量的作用域： 作用域从变量定义的位置开始，到该变量所在的那对大括号结束； 生命周期： 变量从定义的位置开始就在内存中活了； 变量到达它所在的作用域的时候就在内存中消失了； 数据类型：1）：基本数据类型：byte、short、int、long、float、double、char、boolean2）：引用数据类型: 数组、类、接口。 级别从低到高为：byte,char,short(这三个平级)–&gt;int–&gt;float–&gt;long–&gt;double 自动类型转换：从低级别到高级别，系统自动转的； 强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量； 运算符号：1）、算术运算符。 + - * / % %:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。 +:连接符。 ++,– 2）、赋值运算符。 = += -= *= /= %= 3）、比较运算符。 特点：该运算符的特点是：运算完的结果，要么是true，要么是false。 4）、逻辑运算符。 &amp; | ^ ! &amp;&amp; || 逻辑运算符除了 ! 外都是用于连接两个boolean类型表达式。 &amp;: 只有两边都为true结果是true。否则就是false。 |:只要两边都为false结果是false，否则就是true ^:异或：和或有点不一样。 两边结果一样，就为false。 两边结果不一样，就为true. &amp; 和 &amp;&amp;区别： &amp; ：无论左边结果是什么，右边都参与运算。 &amp;&amp;：短路与，如果左边为false，那么右边不参数与运算。 | 和|| 区别：|：两边都运算。 ||：短路或，如果左边为true，那么右边不参与运算。5）、位运算符:用于操作二进制位的运算符。 &amp; | ^ &amp; &lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移)练习：对两个变量的数据进行互换。不需要第三方变量。 int a = 3,b = 5;--&gt;b = 3,a = 5; a = a + b; a = 8; b = a - b; b = 3; a = a - b; a = 5; a = a ^ b;// b = a ^ b;//b = a ^ b ^ b = a a = a ^ b;//a = a ^ b ^ a = b; 练习：高效的算出 2*8 = 2&lt;&lt;3;5，语句。 If switch do while while for 这些语句什么时候用？ 1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。 但是建议使用switch，效率相对较高。 switch(变量){ case 值:要执行的语句;break; … default:要执行的语句; } 工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了 就执行哪个case后面的语句，如果没有相同的则执行default后面的语句； 细节：a：break是可以省略的，如果省略了就一直执行到遇到break为止； b：switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种； c：default可以写在switch结构中的任意位置；如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。 2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。 3）、当某些语句需要执行很多次时，就用循环结构。 while和for可以进行互换。区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。 break:作用于switch ，和循环语句，用于跳出，或者称为结束。 break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。 continue:只作用于循环结构，继续循环用的。 作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。 6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。 java中的函数的定义格式： 修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){ 执行语句； return 返回值； }没有具体的返回值时，返回的返回值类型用void关键字表示。 如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。 return的作用：结束函数。结束功能。 如何定义一个函数？ 函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成： 1）、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。 2）、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&amp;参数个数)。 函数的作用： 1）、用于定义功能。 2）、用于封装代码提高代码的复用性。 注意：函数中只能调用函数，不能定义函数。 主函数： 1）、保证该类的独立运行。 2）、因为它是程序的入口。 3）、因为它在被jvm调用。 函数定义名称是为什么呢？ 答：1）、为了对该功能进行标示，方便于调用。 2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。 重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。 如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。 7，数 组：用于存储同一类型数据的一个容器。好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。 如何在java中表现一个数组呢？两种表现形式。 1）、元素类型[] 变量名 = new 元素类型[元素的个数]； 2）、元素类型[] 变量名 = {元素1，元素2…}； 元素类型[] 变量名 = new 元素类型[]{元素1，元素2…}； //二分查找法。必须有前提：数组中的元素要有序。 public static int halfSeach_2(int[] arr,int key){ int min,max,mid; min = 0; max = arr.length-1; mid = (max+min)&gt;&gt;1; //(max+min)/2; while(arr[mid]!=key){ if(key&gt;arr[mid]){ min = mid + 1; } else if(key&lt;arr[mid]) max = mid - 1; if(max&lt;min) return -1; mid = (max+min)&gt;&gt;1; } return mid; } java分了5片内存。 1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。 栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )； 只要数据运算完成所在的区域结束，该数据就会被释放。 堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。 1：每一个实体都有内存首地址值。 2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。 3：垃圾回收机制。","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"pycharm安装步骤","slug":"pycharm安装步骤","date":"2019-11-03T02:15:31.000Z","updated":"2019-11-03T02:24:57.115Z","comments":true,"path":"2019/11/03/pycharm安装步骤/","link":"","permalink":"http://yoursite.com/2019/11/03/pycharm安装步骤/","excerpt":"","text":"1、首先去Pycharm官网，或者直接输入网址：http://www.jetbrains.com/pycharm/download/#section=windows，下载PyCharm安装包，根据自己电脑的操作系统进行选择，对于windows系统选择下图的框框所包含的安装包。Python环境搭建—安利Python小白的Python和Pycharm安装详细教程 2、选择Windows系统的专业版，将其下载到本地，如下图所示： 3、双击下载的安装包，进行安装，然后会弹出界面： 4、选择安装目录，Pycharm需要的内存较多，建议将其安装在D盘或者E盘，不建议放在系统盘C盘： 5、点击Next，进入下图的界面： Create Desktop Shortcut创建桌面快捷方式，一个32位，一个64位，小编的电脑是64位系统，所以选择64位。 勾选Create Associations是否关联文件，选择以后打开.py文件就会用PyCharm打开。 6、点击Next，进入下图： 默认安装即可，直接点击Install。 7、耐心的等待两分钟左右，如下图： 8、之后就会得到下面的安装完成的界面： 9、点击Finish，Pycharm安装完成。接下来对Pycharm进行配置，双击运行桌面上的Pycharm图标，进入下图界面： 选择Do not import settings，之后选择OK，进入下一步。 10、选择Accept，进入下一步： 11、进入激活界面，选择第二个License server，如下图所示： 之后在License server address中随意输入下面两个注册码中的任意一个即可，Pycharm新注册码1：http://idea.liyang.io或pycharm新注册码2：http://xidea.online，之后点击OK，便可以激活Pycharm了。 12、Pycharm激活后 END","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"win10系统Tomcat环境变量配置步骤","slug":"win10系统Tomcat环境变量配置步骤","date":"2019-11-03T01:58:55.000Z","updated":"2019-11-03T02:02:01.439Z","comments":true,"path":"2019/11/03/win10系统Tomcat环境变量配置步骤/","link":"","permalink":"http://yoursite.com/2019/11/03/win10系统Tomcat环境变量配置步骤/","excerpt":"","text":"一、环境的搭建 1、下载JAVA JDK，选择所要安装的目录安装。官网下载地址：http://java.sun.com/javase/downloads/index.jsp 2、设置环境变量。 在CLASSPATH环境变量后加上（即加上jdk安装路径下的tools.jar和dt.jar文件）： .;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar;path和JAVA_HOME的配置省略（Java初学者必备常识，不会百度“JDK的安装”）。接着下载解压Apache的Tomcat7.0.6，并将其放在自己想要的位置上。 随后在CLASSPATH环境变量中配置Tomcat（即加上Tomcat的lib库中的jsp-api.jar和servlet-api.jar文件） 1E:\\Tomcat\\lib\\jsp-api.jar;E:\\Tomcat\\lib\\servlet-api.jar;4. 在配置好环境后，在Tomcat的bin目录下找到startup.bat文件并双击打开，如果配置成功应该可以看见黑盒子里写的启动信息而不是闪退： 之后打开浏览器输入http://localhost:8080（注意startup.bat文件要一直开着），回车就看到服务器的信息了： 6.如果不能打开可能是端口冲突，需要修改端口。方法是打开Tomcat的conf目录下的server.xml文件，注意用记事本或notepad++等打开，将以下语句的port值8080改为自定义的端口号:","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"2019-10-31JDK的创建步骤","slug":"JDK的创建步骤","date":"2019-10-31T10:25:16.000Z","updated":"2019-10-31T10:31:19.916Z","comments":true,"path":"2019/10/31/JDK的创建步骤/","link":"","permalink":"http://yoursite.com/2019/10/31/JDK的创建步骤/","excerpt":"","text":"JDK的创建步骤1打开浏览器，输入JDK搜索，根据搜索结果下载安装包安装应用 2先接受协议，再根据自己的电脑下载相应的JDK版本，默认安装就行了。 3配置环境变量。找到安装路径，默认安装的一般都是在这个路径下C:\\Program Files\\Java\\jdk1.8.0_77 4然后点击电脑开机键，打开控制面板 5然后点击系统安全，打开进入 6点击系统 7点击“高级系统设置” 8点击高级中的“环境变量” 9在下面的系统变量中点击“新建” 10新建JAVA_HOME、CLASSPATH这两个项，最后在path中添加上去就完成了 11新建CLASSPATH，变量值 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar，注意前面有个点的 12将这两个变量加到path里面，直接在后面添加 ;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin，注意前面要有个分号“;” 13变量操作界面点击确定关闭 14系统高级设置页面点击“确定”关闭 15两个变量配置好了，到时直接可以在控制台编译运行Java文件，运行cmd查看Java环境是否配好。 16输入javac，按回车键，出现下面这些说明编译环境配好了 17再输入java，按回车键，出现下面这些，说明运行环境也好了。 END","categories":[],"tags":[]},{"title":"python知识点总结","slug":"python知识点总结","date":"2019-10-31T09:46:49.000Z","updated":"2019-10-31T09:48:18.950Z","comments":true,"path":"2019/10/31/python知识点总结/","link":"","permalink":"http://yoursite.com/2019/10/31/python知识点总结/","excerpt":"","text":"1、Python的两种编程方式：交互式（随输随运行）和文件式（主要方式；批量运行出结果） 2、一切皆对象，每个对象由标识（id()）、类型（type()）和值（print()）标识。 3、Python采用基于值的内存管理,不同变量赋值为同一个值，ID一样，但是只适用范围在-5至256的整数和短字符串。 4、内置函数（BIF），68个，查看方式：dir(builtins)分类：数值数据类型：int,float,complex,bool,decimal,fractions序列数据类型：字符串（string）、列表（list）、元祖（tuple）、bytes、bytearray集合数据类型：set、frozenset字典数据类型：dict不可变的数据类型：数值Number、字符串String、元祖Tuple可变的数据类型：列表List、字典Dict、集合Set 5、二进制：0b/0B开头八进制：0o/0O开头十六进制;0x/0X开头 6、数值运算函数：abs(x)：绝对值 ；divmod(x,y)：商余 ；pow(x,y,z)：幂余（(x**y)%z） ；round(x,d)：四舍五入d位 ；max/min ； int(x) /float(x) /complex(x) 7、math库：常数：math.pi ；math.fabs(x)：绝对值 ；math.fmod(x,y)：x%y ；math.ceil(x)：向上取整，返回不小于x的最小整数 ；math.floor(x)：向下取整，返回不大于x的最大整数 ；math.modf(x)：返回x的小数和整数部分 ；math.trunc(x)：返回x的整数部分 8、浮点数类型：0.1 + 0.2不等于 0.3 ，浮点数有小尾数。看是否等于可以用round（）函数帮助去小尾数。 9、类型间混合运算：整数 -&gt; 浮点数 -&gt; 复数 10、布尔数据类型（bool）包含两个值-&gt;True（真–1）或假（False–0）。如果表达式的结果为数值类型的0、空字符串（“”）、空元祖（）、空列表[]、空字典{}，则其布尔值为false（假），否则为true（真）。 11、逻辑运算符：and、or、nota and b等于a if not a else b ； a or b 等于a if a else b。not一定会返回true或false；and和or不一定。 12、运算优先级（由高到低）**（指数）&gt; +x.-x（正负号）&gt; *./.%（乘。除。取余）&gt; +. -（加。减）&gt; &amp;(与）&gt; ^（或）&gt; \\（非）&gt;比较大小&gt; not（非）&gt; and（与）&gt;or（或）&gt; lambda表达式 13、序列型数据（1）序列的索引s[i]：如果索引下标越界，导致IndexError；如果索引下标不是整数，导致TypeError。（2）序列的切片（截取序列s的一部分）：顾头不顾尾。（3）序列的加：x + y：连接两个序列； 序列的乘（复制）：x * n：复制n次序列x ；（4）判断子串：x in s ：返回True/False ； s.count(x)：返回x在s中出现的次数 ； s.index(x,i,j)：返回x在s（范围[i,j]）中第一次出现的索引位置。（5）序列的排序：sorted(s, key=None,reverse=False)。reverse为false是为升序，为true时为倒序。返回结果为一个列表。（6）序列的拆封赋值：当变量个数和序列长度相等时，一一对应赋值。如a,b = (1,2)即a = 1,b = 2。不等则导致ValueError。或使用变量（将多个值作为整体赋给变量）或使用临时变量‘_’ 14、字符串类型 比较字符ASCII码值的大小：空格&lt;数字&lt;大写字母&lt;小写字母Unicode变字符：chr(u) ；字符变Unicode：ord(x)format（）方法的格式控制：（1）槽{序号}的使用（2）{参数序号：格式控制标记}，格式控制标记包括：填充、对齐（分别用&lt;、&gt;、^表示左、右和居中对齐）、宽度、精度、类型（b=二进制，c=Unicode,d=十进制，o=八进制，xX=十六进制）。（3）字符串的类型判断：str.isdigit()是否全为数字（0-9）；str.isalpha()是否全为字母；str.isal num()是否全为数字或字母；str.isspace()是否是空白（空格、制表符、换行符等）；str.isprintable()是否可打印（空格和没有东西是可以被打印的）；str.isidentifier()是否满足标识符定义规则（字母或下划线开头，只含数字、字母和下划线）（4）大小写转换：str.capitaiize()：转换为首字母大写，其余小写；str.title()各单词首字母大写。（5）对齐：居中str.center(长度，填充物) ；左对齐：ljust ；右对齐：rjust。填充：str.zfill(长度)相当于右对齐，前方补0。如果str前有正负号，则正负号也算长度，在正负号之后填充。移除：左右两边：str.strip(字符chars) ； 左边：str.lstrip() ；右边;rstrip（）（6）字符串的查找：find和indexstr.find(s):从左至右查找str中是否含s,有则返回第一次出现s的索引位置，否则返回-1str.index（x）：从左至右查找是否含有x，有则返回第一次出现的索引位置，没有则抛出ValueErrorstr.rfind()和str.rindex()就是从右至左查找。（7）字符串的替换：S.replace(old,new,count)。将S中的old替换为new，如果给定count，则只替换前count个old子串。（8）拆分/分割：S.split(分隔符sep,分割次数maxsplit), maxsplit = -1或不指定时，会从左向右搜索完整个字符串。S.rsplit()是从右往左。生成列表。S.partition(sep)，S.rpartition(sep)(从右往左搜索)。搜索S中的子串sep，并从第一个sep处分割，返回一个包含三个元素的元组 –&gt;（sep左边的部分，sep，sep右边的部分）。如果搜索不到sep，则返回中有两个元素为空，partition是后两个元素为空，rpartition是前两个为空。（9）连接组合：S.join（字符串对象）。 当对象为字符串字典时，结果是键的连接。 15、列表类型 列表list是可变对象，则对其增删改查不会改变其的id。除了list.copy().方法：（1）添加：list.appand(x)：将元素x添加到列表的尾部；list.extend(L)：将列表L中所有元素添加到列表的尾部；list.insert(index,x)：在列表指定位置index处添加元素x；（2）删除：list.remove(x)：删除列表中首次出现的元素x；list.pop(kediedai[index])：删除并返回指定位置的元素（可以理解为挖取出），list为空就抛IndexError异常；list.clear()：删除列表中所有元素，但保留列表对象。（3）排序：list.reverse()：倒序；list.sort()：排序（正或倒）；（4）其他：list.index(x)：返回值为x首次出现的下标；list.count(x)：返回x的出现总次数；list.copy() ：返回列表对象的浅拷贝。很厉害！！它可以改变列表的ID！浅拷贝——只拷贝一层。如果拷贝对象只有一层，那么同b = a[:]，两个变量相互独立的。但如果拷贝对象只有一层，就会有影响，会跟着改变。（详见例题）！！列表推导式：[新元素表达式 for 临时变量 in 可迭代对象 if 条件表达式] 16、集合类型集合中的元素没有顺序，且不重复。集合set是可变的，用大括号表示。但是{}表示空字典；set()表示空集合，用set（）创建集合时，会将元素一个一个拆开，如’hello’变成’h’,‘e’,‘l’,‘l’,‘o’。集合中元素要是固定数据类型：整数、浮点数、字符串、元组等。不可为可变的列表、字典、集合。利用集合过滤掉重复的元素。4种基本操作：交（&amp;）、并（|）、差（-）、补（^）S.add() ;S.clear() ;S.copy() ; S.remove() ;len(S) ;x (not)in S ;**S.pop()：随机返回S中的一个元素，如果S为空，产生KeyError.(区分list.pop([index]))特有的：S.discard(X)；如果x在S中，移除x，不在，不报错。主要三大用途：成员关系测试、元素去重、删除数据项。 17、字典类型（映射）{建（key）：值（value）}。键不能重复，且是不可变对象。值可变。元素没有顺序。创建一个空字典：dict（） ；创建字典：dict(‘a’=1,‘b’=2)/dict(‘a’:1,‘b’:2)/dict((‘a’,1),(‘b’,2))查找值：Dict[key] ；修改键值：dict[key] = new_value ；增添新键值：dict[new_key] = new_value .D.keys()：返回所有键的列表,如dict_keys([‘a’, ‘b’, ‘c’])；D.values()：返回所有值的列表,如dict_values([1, 2, 3])；D.items()：返回所有的键值对的列表,如dict_items([(‘a’, 1), (‘b’, 2), (‘c’, 3)])；D.get(key,v)：键存在则返回相应值，否则返回None（自定义了v时，返回v的内容）;D.pop(key.value)：键存在则返回相应值，同时删除键值对，否则返回None；D.popitem()：随机取出一个键值对，以元组（key，value）形式返回；D.setdefault(k,v)：如果键k存在，返回对应值，否则添加项目k = v,v默认为None；D.update(dict)：更新或添加键值对；D.clear()：删除所有的键值对；del.D[key]：删除key对应的键值对。如果key不存在，则抛出KeyError。 遍历：for 变量名 in 字典名： 18、可变与不可变（关于值）可变：列表（有序）、集合（无序）、字典（无序）不可变：字符串（有序）、元组（有序）Python是基于值的内存管理方式，举例：a=[1,2,3],b=[1,2,3]，a==b成立。 但是id(a)与id(b)不相等，id(a[0])==id(b[0])成立。总结就是关乎值的就相等什么叫可变？即值是可变的，但id是固定不变的。例如可变的列表，修改列表L中的一个元素的值，列表L的id是不变的。不管是可变还是不可变的序列类型：（1）分片必定产生新的序列；（2）“+”号在等号右边（L=L+[i]），必定产生新的序列。然后将新的序列地址赋予给等号左边的变量。（每一次执行时都会将原列表复制一次，L指向新列表，并在新列表中加入新元素）对三种列表添加方法进行总结：（1）L=L+[i]在每一次执行时都会将原列表复制一次，L指向新列表，并在新列表中加入新元素。（2）L.append(i)只是将新元素直接添加到原列表中，不会产生新列表。（3）L+=[i]的执行效果和L.append(i)类似，也是在原列表中直接添加元素，不会复制原列表。b = a VS b = a[:]b = a时，b就是跟着a变化，并且a与b的id一样。b = a[:]时，b与a是独立的整体，id就不同，只不过指向了同一个值。对a做修改（增删改查），对b没有影响。 19、程序的三种基本结构：顺序结构、·分支结构（if-else、elif）、·循环结构（遍历：for…in、条件：while。循环控制：break/continue）。异常值处理：try-except。二分支结构简单语法：表达式1 if 条件 else 表达式2循环结构分遍历循环（for）和无限循环（while）：遍历循环：for 循环变量 in 遍历结构：语句块（从遍历结构逐一提取元素，放在循环变量中，对每一个提取出的元素执行一次语句块。）无限循环：while 条件：语句块。判断条件为True就一直循环，为false时魂环结束，执行与while同级别缩进的后续语句。break用于结束当前循环，如果有两层循环，break用于跳出最内层for或while循环，脱离该循环后程序从循环后代码继续执行；continue用来结束当前循环的当次循环过程，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。当有输入要求时，可运用异常值处理try：except： 20、函数（1）形参与实参：定义函数时的参数是形参，调用函数时的参数是实参。（2）参数传递的方法：位置参数、默认值参数、关键字参数、命名关键字参数。。。位置参数：按位置顺序传递参数值，位置参数要在所有参数之前，是第一个参数；关键字参数：关键字参数就是在调用函数，传入实参时指定形参的变量名。关键字不用遵守位置的对应关系。参数之间的顺序可以任意调整。关键字传递可以和位置传递混用。但位置参数要在关键字参数之前。举例：def hello(name,age = 11,gender = ‘F’):（age = 11,gender = ‘F’就是关键字参数）。举例：def hello(name,age = 11,gender = ‘F’):（age = 11,gender = ‘F’就是关键字参数）默认值参数：定义参数时已经给定值，一般参数为不可变对象，（如果为可变的空列表，可用于装位置参数）；可变数量参数：args、kw带有星号的可变参数只能出现在参数列表的后面。调用时，参数被当作元组类型传递到函数中。(如： def func(*args): -&gt; func(10,20))带双星号（）的参数，在使用时必须指定参数值，使用key=value这种形式，只能出现在参数列表的最后。调用时，kw后的那些参数被当作字典类型传递到函数中。（如：def func(kw): -&gt; func(a=10,b=20)）强制命名参数：参数带星号或者就是一个星号（def f(*c或,a,b,c)），强制命令参数c 的含义是它后面的参数必须用实名调用，即必须用 a = … , b = … 来调用，不能只写值。Python中只有函数，函数是有返回值的，*如果没有return，默认返回None。**return返回多个值时，多个值以元组形式保存。 21、比较（1）list.sort（）与全局sorted（）list.sort(key = None,reverse = False)是列表内置排序方法。但其返回值为None（x.sort()的结果、print（x.sort()）、x = x.sort()后x的结果都是None）,只有当文字说“执行语句x.sort（），x的值为”，x.sort（）作用的结果，需要通过打印被作用的列表才可以查看结果。true是倒序，false是正序。sorted（）：Python内置方法。返回新的列表。（2）list.reverse（）和reversed（）list.reverse()返回的是None，其作用的结果，需要通过打印被作用的列表才可以查看结果。reversed()：内置方法。经过reversed（）作用之后，返回的是一个吧序列值经过倒序的迭代器，所以，需要通过遍历或list、tuple或next（）方法，才能获得作用后的值。（3）字符串的查找：find和indexstr.find(s):从左至右查找str中是否含s,有则返回第一次出现s的索引位置，否则返回-1str.index（x）：从左至右查找是否含有x，有则返回第一次出现的索引位置，没有则抛出ValueErrorstr.rfind()和str.rindex()就是从右至左查找。 22、函数变量的作用域（1）局部变量、全局变量、globalglobal：用于在函数中直接修改全局变量的值。（2）内嵌函数内嵌函数的作用域仅限其所在的函数体内。如果要在内部函数中修改外部函数中的局部变量的值，使用nonlocal关键字。 END","categories":[],"tags":[]},{"title":"JAVA汉诺塔问题","slug":"JAVA汉诺塔问题","date":"2019-10-31T03:49:56.000Z","updated":"2019-10-31T03:51:52.768Z","comments":true,"path":"2019/10/31/JAVA汉诺塔问题/","link":"","permalink":"http://yoursite.com/2019/10/31/JAVA汉诺塔问题/","excerpt":"","text":"汉诺塔问题：有三根柱子A,B,C，其中A上面有n个圆盘，从上至下圆盘逐渐增大，每次只能移动一个圆盘，并且规定大的圆盘不能叠放在小的圆盘上面，现在想要把A上面的n个圆盘全部都移动到C上面，输出移动的总步数以及移动的过程分析：//先求出移动的总步数1，假设g（n）表示n个圆盘时的移动总的步数，当n=1时，g(1)=1;2.现在可以把g(n)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B上面，相当于将n-1个圆盘从A移动到C，因此需要g(n-1)步； 2&gt;然后将剩下的最大的圆盘从A移动到C，需要1步； 3&gt;最后再将n-1个圆盘从B通过A移动到C上面，相当于将n-1个圆盘从A移动到C，因此也需要g(n-1)步； 因此可以得出递归关系式：g(n) = 2*g(n-1)+1;//现在我们在来求出移动的过程1.假设hm(m,a,b,c)表示将m个圆盘从a通过b移动到c的过程，假设mv(a,c)输出一次a到c的过程，即print a–&gt;c2.初始化hm，当m=1时，hm(1,a,b,c)=mv(a,c);3.可以把hm(m,a,b,c)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B，此时b和c进行互换，也就是 hm(m-1,a,c,b); 2&gt;然后将剩下的最大的圆盘从A移动到C，也就是hm(1,a,b,c); 3&gt;最后将n-1个圆盘从B通过A移动到C，此时b和a进行交换，也就是 hm(m-1,b,a,c); 最终得到过程的递归关系式：hm(m,a,b,c) = hm(m-1,a,c,b)+1+hm(m-1,b,a,c); 代码：public class test{public static void main(String[] args){ Scanner in = new Scanner(System.in); int n = in.nextInt(); test t = new test(); //获取总的步数 System.out.println(“需要移动的总步数为:” +t.getSum(n)); //获取移动的过程 t.hm(n,’a’,’b’,’c’); } //获取总步数 public int getSum(int n){ if(n == 1) return 1; return 2 * getSum(n-1) +1 ; } //获取移动的过程 public void hm(int m,char a,char b,char c){ if(m == 1) move(a,c); hm(m-1,a,c,b); move(a,c); hm(m-1,b,a,c); } //输出一次移动的过程 public void move(char a,char c){ System.out.print(a + “–&gt;” + c + “ “); } }","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2019-10-13T10:01:23.000Z","updated":"2019-10-13T10:02:53.057Z","comments":true,"path":"2019/10/13/第一篇博客/","link":"","permalink":"http://yoursite.com/2019/10/13/第一篇博客/","excerpt":"","text":"Javaoop总结1.类与对象 抽象的，泛指的，是指从某一类具有相同属性和方法的对象中抽取出来 class代表类 类的作用；实例化对象，方法，工具类 类中分两大块：属性（成员变量） 方法（成员方法） 类如何实例化对象？ new Person p = new Person(); p.name = “张三”; p.sex = “男”; p：对象名 Person p1 = new Person();2. 属性与方法 方法的调用：对象名.方法名 匿名对象调用方法：new 类().方法名 new Person().getA(); int c = new Person().getD(10, 20); //实参 System.out.println(c);3.static static 静态，static用来修饰属性、方法 用static修饰属性：共有的属性——实例化出来的对象，用static修饰的具有相同的值。 用static修饰方法：能通过类名直接调用 4.封装, oopd三大特征之一； 属性私有化，公开setter和getter方法； 单例模式 只能实例化一次； 实现单例式的三个步骤：第一：私有化构造方法 private 类名（）{ } 第二：公开一个代理方法 private static 类名 方法名（）{ 类名 d=null； if（count&lt;1）{ d=new 类名（）； count++; } return d; } 第三：私有化一个静态属性，用来统计new的个数 private static int count=0; 5.继承,oop三大特征之一 继承 会让两个类产生一种关系 父类-子类 父类：从子类中抽取出共同的属性和共同的方法，放到父类中， 然后让子类继承父类，那子类就具有父类的属性和方法 继承的关键词：extends 类的继承格式 class 父类 { } class 子类 extends 父类 { } (1)父类中私有的属性和方法，子类是不能继承的 (2)父类的构造方法，子类是不能继承的 (3)父类是跨包的，除public以外的都不能被继承super 子类用来访问父类的方法或者属性 super.方法 super.属性 super()只能放在子类的构造方法中，并且只能放在第一行 重写 子类重写父类的方法； 方法名 +快捷键 多态,oop三大特征之一 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性多态存在的三个必要条件继承重写父类引用指向子类对象向上转型子类向父类的转换&lt;父类型&gt; &lt;引用变量名&gt;=new&lt;子类型&gt;;向下转型父类型转换为子类型&lt;子类型&gt;&lt;引用变量名&gt;=(&lt;子类型&gt;）&lt;父类型的引用变量&gt;; 抽象 (1)抽象 abstract abstract能修饰什么？类，方法(2) 用abstract修饰类叫抽象类 特点：抽象类不能被实例化，但能被继承 (3)用abstract修饰的方法叫抽象方法 特点：1.抽象方法没有方法体 2.抽象方法必须放在抽象类中，抽象类中的方法不一定是抽象方法 3.抽象类被子类继承后，那么子类要重写父类中的抽象方法，除非子类也是抽象类 访问权限private (私有的) 默认 (友好的) protected (受保护的) public (公共的) 9.final (1)final修饰类中的属性或者变量 无论属性是基本类型还是引用类型，final所起的作用都是变量里面存放的“值”不能变。 (2)final修饰类中的方法 作用：可以被继承，但继承后不能被重写。 (3)final修饰类 作用：类不可以被继承。 10.接口（重点） 创建接口类 public interface 接口的声明语法格式 interface 接口名称 extends 其他的接口名 { // 声明变量 // 抽象方法 } 接口关键字： interface 类要实现接口：implements class 类名 extends 父类名 implements 接口，接口，…{ //类成员 } 接口中的方法全是抽象方法 接口中的方法全部要公开public 接口不能被实例化 接口可以被多实现 接口中的属性全部是静态常量","categories":[],"tags":[]},{"title":"Readers are welcome to browse","slug":"Readers-are-welcome-to-browse","date":"2019-10-10T10:19:43.000Z","updated":"2019-10-10T10:20:41.888Z","comments":true,"path":"2019/10/10/Readers-are-welcome-to-browse/","link":"","permalink":"http://yoursite.com/2019/10/10/Readers-are-welcome-to-browse/","excerpt":"","text":"public class HelloWorld { /* 第一个Java程序 * 它将打印字符串 Hello World */ public static void main(String []args) { System.out.println(“Hello World”); // 打印 Hello World }}","categories":[],"tags":[]},{"title":"post title with whitespace","slug":"post-title-with-whitespace","date":"2019-10-10T07:03:54.000Z","updated":"2019-10-10T09:56:19.604Z","comments":true,"path":"2019/10/10/post-title-with-whitespace/","link":"","permalink":"http://yoursite.com/2019/10/10/post-title-with-whitespace/","excerpt":"","text":"python","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-09T13:21:42.052Z","updated":"2019-10-09T13:21:42.052Z","comments":true,"path":"2019/10/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}