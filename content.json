{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"HTML知识点总结","slug":"HTML知识点总结","date":"2019-11-23T05:20:10.000Z","updated":"2019-11-23T05:22:39.647Z","comments":true,"path":"2019/11/23/HTML知识点总结/","link":"","permalink":"http://yoursite.com/2019/11/23/HTML知识点总结/","excerpt":"","text":"HTML 初识HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 我是斜体的字体 1 1234567可以用Ctrl+D复制上一行1 HTML标签：作用所有HTML中标签的一个根节点。2 head标签：作用：用于存放：title,meta,base,style,script,link注意在head标签中我们必须要设置的标签是title3.title标签：作用：让页面拥有一个属于自己的标题。4.body标签：作用：页面在的主体部分，用于存放所有的HTML标签：p,h,a,b,u,i,s,em,del,ins,strong,imgHTML标签分类在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 、、都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素1.双标签&lt;标签名&gt; 内容 &lt;/标签名&gt;1该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 比如 我是文字 1 2.单标签&lt;标签名 /&gt;1单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。 比如 1 HTML标签关系标签的相互关系就分为两种：1.嵌套关系 1 2.并列关系 12 文档类型 1 这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号 字符集 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。gb2312 简单中文 包括6763个汉字BIG5 繁体中文 港澳台等用GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312UTF-8则包含全世界所有国家需要用到的字符记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。不管是谁都能看懂这块内容是什么。遵循的原则：先确定语义的HTML ，再选合适的CSS。HTML标签首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。标题标签 (熟记)单词缩写： head 头部. 标题为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 、、、、和1标题标签语义： 作为标题使用，并且依据重要性递减1其基本语法格式如下： 标题文本 1 注意： h1 标签因为重要，尽量少用 单词缩写： paragraph 段落在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 文本内容 1 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签(认识) 单词缩写： horizontal 横线 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： 是单标签 1 在网页中显示默认样式的水平线。 换行标签 单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 1 这时如果还像在word中直接敲回车键换行就不起作用了。 div span标签(重点) div span 是没有语义的 是我们网页布局主要的2个盒子 div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 div的宽度是100% span宽度和高度都取决于内容的高度和宽度 span是小盒子 包裹小元素 或者是简单的文本 $美少女战士$ 默认字体 1234567891011 语法格式： 这是头部 今日价格 1 文本格式化标签(熟记) 在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈 标签属性 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： 内容 1 在上面的语法中， 1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=“value” 的格式 比如: 1 属性 是 宽度 值 是 400 图像标签img (重点) 单词缩写： image 图像 HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。其基本语法格式如下： 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 1 链接标签(重点) 单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下： 文本或图像 1 href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用 target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 < a href=“index.html”> 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=\"#\")，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位 （难点） 通过创建锚点链接，用户能够快速定位到目标内容。 创建锚点链接分为两步： 1.使用“a href=”#id名>“链接文本\"创建链接文本。 2.使用相应的id名标注跳转目标的位置。123base 标签base 可以设置整体链接的打开状态base 写到 之特殊字符标签 （理解）路径可以分为： 相对路径和绝对路径相对路径 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如。图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如。图像文件位于HTML文件的上一级文件夹：在文件名之前加入“…/” ，如果是上两级，则需要使用 “…/ …/”，以此类推，如。 绝对路径绝对路径“D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。列表标签什么是列表？ 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： 列表项1 列表项2 列表项3 ...... 123456 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 中只能嵌套，直接在标签中输入其他标签或者文字的做法是不被允许的。 与之间相当于一个容器，可以容纳所有元素。 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol （了解）有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： 列表项1 列表项2 列表项3 ...... 123456 所有特性基本与ul 一致。 但是实际工作中， 较少用 ol ，因此我们用一句话来总结下 ol： 自定义列表（理解） 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： 名词1 名词1解释1 名词1解释2 ... 名词2 名词2解释1 名词2解释2 ... 12345678910 程序如下： $美少女战士$ 11 22 33 44 55 美国 34 &lt;/li&gt; &lt;li&gt;121&lt;/li&gt; &lt;li&gt;121&lt;/li&gt; &lt;li&gt;121&lt;/li&gt; &lt;li&gt;121&lt;/li&gt; 配送方式 上门自提 上门自提 上门自提 上门自提 上门自提 123456789101112131415161718192021222324252627282930313233343536373839404142434445 表格 table(会使用) ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 创建表格 在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下： 单元格内的文字 ... ... 1234567 在上面的语法中包含三对HTML标签，分别为 、、，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释。 1.table用于定义一个表格。 2.tr 用于定义表格中的一行，必须嵌套在 table /table标签中，在 table /table中包含几对 tr /tr，就有几行表格。 3.td /td：用于定义表格中的单元格，必须嵌套在标签中，一对 中包含几对，就表示该行中有多少列（或多少个单元格）。 注意： 1. 中只能嵌套 1 2. 标签，他就像一个容器，可以容纳所有的元素 1 表格属性 边框 可以给表格以及表格中的单元格设置1像素的边框，数值变大只有table的边框变粗，单元格边框不变。 单元格间距 合并单元格rowspan 属性规定单元格可纵跨的行数。例如：该单元格占两行一列colspan 属性规定单元格可横跨的列数。例如：该单元格占一行两列 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签替代相应的单元格标签即可。表格结构（了解）在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示： ：用于定义表格的头部。 必须位于 标签中，一般包含网页的logo和导航等头部信息。 ：用于定义表格的主体。 位于标签中，一般包含网页中除头部和底部之外的其他内容。12345678910合并单元格跨行合并：rowspan 跨列合并：colspan合并单元格的思想：​ 将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。​ 公式： 删除的个数 = 合并的个数 - 1表单标签 表单控件：​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。提示信息：​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。表单域：​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。input 控件(重点)在上面的语法中，标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，标签还可以定义很多其他的属性，其常用属性如下表所示。label标签(理解)label 标签为 input 元素定义标注（标签）。作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点如何绑定元素呢？for 属性规定 label 与哪个表单元素绑定。Male12textarea控件(文本域)如果需要输入大量的信息，就需要用到标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 文本内容123下拉菜单使用select控件定义下拉菜单的基本语法格式如下 选项1 选项2 选项3 …123456注意： 中至少应包含一对。在option 中定义selected =” selected “时，当前项即为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 各种表单控件 123 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。method用于设置表单数据的提交方式，其取值为get或post。name用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。HTML5新标签与特性文档类型设定 document HTML:XHTML:HTML5 字符设定 ：HTML与XHTML中建议这样去写 ：HTML5的标签中建议这样去写 常用新标签 header：定义文档的页眉nav：定义导航链接的部分footer：定义文档或节的页脚article：标签规定独立的自包含内容section：定义文档中的节（section、区段）aside：定义其所处内容之外的内容 常用新属性 属性**用法**含义**** placeholder**** 占位符提供可描述输入字段预期值的提示信息 autofocus**** 规定当页面加载时 input 元素应该自动获得焦点 multiple**** 多文件上传 autocomplete**** 规定表单是否应该启用自动完成功能 required**** 必填项 accesskey**** 规定激活（使元素获得焦点）元素的快捷键 新增的type属性值： 类型**使用示例**含义**** email**** 输入邮箱格式 tel**** 输入手机号码格式 url**** 输入url格式 number**** 输入数字格式 search**** 搜索框（体现语义化） range**** 自由拖动滑块 time**** date**** datetime**** month**** week**** 综合案例 学生档案 姓名: 手机号码: 邮箱地址: 所属学院: 入学成绩: 基础水平: 入学日期: 毕业日期: 123456789101112131415161718192021222324252627 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体 audioHTML5通过标签来解决音频播放的问题。可以通过附加属性可以更友好控制音频的播放，如：autoplay 自动播放controls 是否显不默认播放控件loop 循环播放由于版权等原因，不同的浏览器可支持播放的格式是不一样的多媒体 videoHTML5通过标签来解决音频播放的问题。同音频播放一样，使用也相当简单同样，通过附加属性可以更友好的控制视频的播放autoplay 自动播放controls 是否显示默认播放控件loop 循环播放width 设置播放窗口宽度height 设置播放窗口的高度","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"C语言基础概念","slug":"C语言基础概念","date":"2019-11-03T03:58:30.000Z","updated":"2019-11-03T03:59:19.808Z","comments":true,"path":"2019/11/03/C语言基础概念/","link":"","permalink":"http://yoursite.com/2019/11/03/C语言基础概念/","excerpt":"","text":"C语言程序设计基础知识点1、函数是C语言的基本构成单位。main函数是C语言程序的唯一入口。2、C语言程序开发过程。编译过程：将以.c或.cpp结尾的源程序文件经过编译成计算机能识别的二进制文件目标文件，编译过程中，编译器会检查每条语句的语法错误。链接过程：连接器将所生成的目标文件链接生成最后可直接运行的的执行文件。3、算法：解决问题的具体步骤的描述。算法的特性：—有穷性：算法必须在有限步骤后结束，而且每一步都在有限时间内完成。—确定性：每条指令无二义性。相同的输入只能得到相同的输出。—可行性：算法描述中的操作和功能都可以通过已实现的基本运算执行有限次来实现。—输入：算法有零个或多个输入。—输出：算法至少有一个或多个输出。4、变量命名规则：大小写字母、数字和下划线组成，可以以字母或下划线开头，不能使C语言的关键字。5、数据类型：基本数据类型有int，char，float，double，void整形： int 占4个字节16位。-3276832767无符号整形： unsigned int 占4个字节16位。065537短整型： short int 占2个字符8位。无符号短整型：unsigned short 占2个字节8位。长整型： long int 占4个字节32位。无符号长整型：unsigned long int 占4个字字节32位。float和double类型的异同：–同：都是C语言的浮点数据类型，带精度的数据类型。–异：占用内存不同：单精度浮点型占用4个字节，双精度浮点型占用8个字节。有效数位不同：float有效数位8个，double有效数位16个。char类型：内存中以ASCII码存放，在其取值范围内可以与整数一起使用，如：char c = ‘A’ + 10；则c为K。常见的字符对应的ASCII码：’0’：48，’A’：65，’a’：97大小写字母ASCII值相差32。6、运算符算术运算符：+ - * / % ++ – (注：%两边的对象都需要是正数)赋值运算符：= += -= *= /= %=关系运算符：&gt; &lt; &gt;= &lt;= == !=逻辑运算符：&amp;&amp; || ！三元运算符：表达式1 ？表达式2 ：表达式3运算符优先级：（ ）： 自左向右结合! ++ – sizeof： 自右向左结合 / %： 自左向右结合 ： 自左向右结合&lt; &gt; &lt;= &gt;=：自左向右结合== !=： 自左向右结合&amp;&amp; ||： 自左向右结合= += -= = /= %= 自左向右结合7、类型转换自动转换：不同数据类型的数据进行运算时，由编译器自动完成。转换规则：由短整型和字符型向整形转换，整形向无符号整形转换，无符号整形向长整型转换，长整型和单精度浮点型向双精度浮点型转换。（字节少的向字节多的转换）强制类型转换：（类型名）变量名或数值。如果是高向低转换则会丢失多余的精度。低精度向高精度转换，多余的补上0。8、输入输出（1）printf函数常见格式控制字符%d：将参数按整形输出。%c：按字符输出。%s：输出字符串。%f：带小数点形式输出。%md：输出数据占m个位宽，数据长度左补空格，超出按原样输出。%m.nf：n表示小数位数。（2）putchar( )： 向终端输出一个字符。注意：使用没有换行符。（3）puts( )： 向终端输出字符串。int puts(const char *string);（4）scanf( )： 输入。int scanf(const char * restrict format,…); 注：从终端中输入空格，会使scanf获取终端，空格后面的舍弃。（5）getchar( )：向终端接受一个字符。getc(stdin)（6） gets( )：向终端接受一个字符串。char *gets(char *string);注意：gets不检测字符串string的大小，容易造成溢出，且LinuxC不支持该函数，可以使用fgets代替。fgets(s, size, stdin)。9、程序结构设计（1）程序的三种基本机构：顺序结构，分支结构，循环结构。（2）分支结构：if if-else switch-case注意1：if-else语句的二义性，C语言规定else永远与最近的if配对。合理的编程规范，if-else每一个语句块均使用{ }括出。注意2：switch括号中要求数据类型为整形或字符表达式。注意case后面要有break跳出，不然会一直往下执行，知道找到一个break跳出或者继续往下执行完default。（3）循环结构：while( ) do-while( )； for( )（4）continue：只能在循环里面试用，作用：结束该次循环，直接执行下一次循环。（5）break：结束该层循环。10、数组数组的特点：数组在内存中连续存储多个元素的结构，一个数组存放的元素的地址是连续的。数组的大小是固定的，所有的元素的数据类型是相同的。数组的定义和初试化：定义：数据类型 数组名[数组大小]；一维数组初始化：int array[10] = {10,9,8,7,6,5,4,3,2,1}；int array[10]={10,9,8,7,6,5,4,3,2,1,0};//越界数组初试化元素个数小于数组大小，后面默认为0。 二维数组初始化：int array[2][3]={ {1,2,3}, {4,5,6} };定义二维数组可以省略第一维的值，但不能省略第二维的值。二维数组的存放顺序是按行存放。如：int array[][3]={ {1,2,3}, {4,5,6} };//定义2行3列数组int array[2][]={ {1,2,3}, {4,5,6} };//错误，不能省列值。数组的使用：数组的索引是从0开始。一维数组：array[序列号]二维数组：array[行序列号][列序列号]11、字符串（1）字符串是由双引号括起来的存放在连续内存地址的任意字符。C语言中没有特定的字符串变量，通常使用数组存放字符串。字符串的定义方式：char string = “Hello”;//使用指针定义一个字符串常量char string[]=”Hello”;//使用数组定义一个字符串。（2）字符数组与字符串的区别：定义：字符数组：存储字符的数组。字符串数组：一种特殊的字符数组，存放以\\0结尾。长度：字符数组大小与字符数相同，字符串数组的大小等于字符数加上结束符’\\0’。（3）字符串处理函数：拷贝char *strcpy(char dest, const char *src)：拷贝字符串，注意该函数没有限定大小，容易越界，char *strncpy(char *dest,char *src,size_t n);拷贝字符串，对strcpy进行优化，限制了拷贝长度，注意如果长度size与dest数组大小相等时，会缺少结束符\\0。int sprintf( char *buffer, const char *format [, argument] … );建议使用sprintf函数拷贝字符串。void memcpy(void *dest, const void *src, size_t n); 内存块拷贝，需要注意的是第一第二个参数需要是指针。strcat：字符串连接。extern char *strcat(char *dest, const char *src);strcmp(str1, str2)：字符串比较。相同返回0。strlen( s1[], s2[])：字符串长度。12、指针指针也是一个变量，只不过该变量存放的是另外一个对象的内存地址。声明和初始化：指针变量类型 *指针变量名。使用指针时，需要在定义的同时进行声明，防止出现野指针。指针变量名=NULL；指针的运算：指针变量 = 地址;int a[5]; int *p = a;定义数组名为a的数组，将数组的首地址赋值给p。p指向数组的第一个元素。&amp;a[0]表示数组的第一个元素的地址。数组第1个元素的地址： a，&amp;a[0]，p数组第i+1个元素的地址：a+i, &amp;a[i], p+i, &amp;p[i]数组的第一个元素的值： a[0], p[0], *a, *p数组的第i+1个元素的值： a[i], p[i], *(a+i), *(p+i) – ：使用一次递增递减，指针就移动一个单位，一个类型为T的指针的移动。指针加上或减去某个整数值n：指针将移动n个单位。13、typedef ：typedef 类型名 标识符typedef只是将已经存在的类型用一个新的名字来代表。typedef可以为各种类型说明一个新名，但不能用来为变量名说明一个新名。14、枚举：enum 枚举名 {符号1，符号2…}枚举类型为一组在逻辑上密不可分的整形提供便于记忆的符号。默认情况下第一个枚举符号值为0，往后一个加1。15、结构结构是一种构造数据类型，它是由若干数据项组合而成的复杂的数据对象，这些数据项称为结构成员。定义结构：struct structrename{datatype variable1；datatype variable2；…};声明结构变量：struct 结构名 结构变量名；表示结构变量成员：变量名.成员名;16、预处理命令宏定义：#define 标识符 字符串：在编译时，将用字符串替换程序中出现的所有标识符。如：#define PI 3.14文件包含处理：#include“文件名”：系统将先在用户当前目录下查找文件，找不到将在系统目录下找。#include&lt;文件名&gt;：&lt;&gt;系统只在系统目录中查找该文件。","categories":[],"tags":[]},{"title":"JAVA基础知识","slug":"JAVA基础知识","date":"2019-11-03T02:39:49.000Z","updated":"2019-11-03T02:41:16.970Z","comments":true,"path":"2019/11/03/JAVA基础知识/","link":"","permalink":"http://yoursite.com/2019/11/03/JAVA基础知识/","excerpt":"","text":"java基础知识概述：1991 年Sun公司的James Gosling（詹姆斯·高斯林）等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器； 1994年将Oak语言更名为Java； Java的三种技术架构: JAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发； JAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础； JAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序； 1，JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。 2，JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。 3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。 环境变量的配置：1）：永久配置方式：JAVA_HOME=%安装路径%\\Java\\jdk path=%JAVA_HOME%\\bin 2）：临时配置方式：set path=%path%;C:\\Program Files\\Java\\jdk\\bin 特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。 classpath的配置:1）：永久配置方式：classpath=.;c:;e:2）：临时配置方式：set classpath=.;c:;e:\\ 注意：在定义classpath环境变量时，需要注意的情况 如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件； 如果指定了classpath，那么会在指定的目录下查找要运行的类文件。 还会在当前目录找吗？两种情况： 1）：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。 2）：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。 一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。 4，javac命令和java命令做什么事情呢？ 要知道java是分两部分的：一个是编译，一个是运行。javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。java：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数. java语法基础：1，关键字：其实就是某种语言赋予了特殊含义的单词。保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。 2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；注意： 1），数字不可以开头。 2），不可以使用关键字。 3，常量：是在程序中的不会变化的数据。 4，变量：其实就是内存中的一个存储空间，用于存储常量数据。 作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。 特点：变量空间可以重复使用。 什么时候定义变量？只要是数据不确定的时候，就定义变量。 变量空间的开辟需要什么要素呢？ 1，这个空间要存储什么数据？数据类型。 2，这个空间叫什么名字啊？变量名称。 3，这个空间的第一次的数据是什么？ 变量的初始化值。 变量的作用域和生存期: 变量的作用域： 作用域从变量定义的位置开始，到该变量所在的那对大括号结束； 生命周期： 变量从定义的位置开始就在内存中活了； 变量到达它所在的作用域的时候就在内存中消失了； 数据类型：1）：基本数据类型：byte、short、int、long、float、double、char、boolean2）：引用数据类型: 数组、类、接口。 级别从低到高为：byte,char,short(这三个平级)–&gt;int–&gt;float–&gt;long–&gt;double 自动类型转换：从低级别到高级别，系统自动转的； 强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量； 运算符号：1）、算术运算符。 + - * / % %:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。 +:连接符。 ++,– 2）、赋值运算符。 = += -= *= /= %= 3）、比较运算符。 特点：该运算符的特点是：运算完的结果，要么是true，要么是false。 4）、逻辑运算符。 &amp; | ^ ! &amp;&amp; || 逻辑运算符除了 ! 外都是用于连接两个boolean类型表达式。 &amp;: 只有两边都为true结果是true。否则就是false。 |:只要两边都为false结果是false，否则就是true ^:异或：和或有点不一样。 两边结果一样，就为false。 两边结果不一样，就为true. &amp; 和 &amp;&amp;区别： &amp; ：无论左边结果是什么，右边都参与运算。 &amp;&amp;：短路与，如果左边为false，那么右边不参数与运算。 | 和|| 区别：|：两边都运算。 ||：短路或，如果左边为true，那么右边不参与运算。5）、位运算符:用于操作二进制位的运算符。 &amp; | ^ &amp; &lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移)练习：对两个变量的数据进行互换。不需要第三方变量。 int a = 3,b = 5;--&gt;b = 3,a = 5; a = a + b; a = 8; b = a - b; b = 3; a = a - b; a = 5; a = a ^ b;// b = a ^ b;//b = a ^ b ^ b = a a = a ^ b;//a = a ^ b ^ a = b; 练习：高效的算出 2*8 = 2&lt;&lt;3;5，语句。 If switch do while while for 这些语句什么时候用？ 1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。 但是建议使用switch，效率相对较高。 switch(变量){ case 值:要执行的语句;break; … default:要执行的语句; } 工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了 就执行哪个case后面的语句，如果没有相同的则执行default后面的语句； 细节：a：break是可以省略的，如果省略了就一直执行到遇到break为止； b：switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种； c：default可以写在switch结构中的任意位置；如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。 2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。 3）、当某些语句需要执行很多次时，就用循环结构。 while和for可以进行互换。区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。 break:作用于switch ，和循环语句，用于跳出，或者称为结束。 break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。 continue:只作用于循环结构，继续循环用的。 作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。 6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。 java中的函数的定义格式： 修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){ 执行语句； return 返回值； }没有具体的返回值时，返回的返回值类型用void关键字表示。 如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。 return的作用：结束函数。结束功能。 如何定义一个函数？ 函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成： 1）、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。 2）、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&amp;参数个数)。 函数的作用： 1）、用于定义功能。 2）、用于封装代码提高代码的复用性。 注意：函数中只能调用函数，不能定义函数。 主函数： 1）、保证该类的独立运行。 2）、因为它是程序的入口。 3）、因为它在被jvm调用。 函数定义名称是为什么呢？ 答：1）、为了对该功能进行标示，方便于调用。 2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。 重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。 如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。 7，数 组：用于存储同一类型数据的一个容器。好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。 如何在java中表现一个数组呢？两种表现形式。 1）、元素类型[] 变量名 = new 元素类型[元素的个数]； 2）、元素类型[] 变量名 = {元素1，元素2…}； 元素类型[] 变量名 = new 元素类型[]{元素1，元素2…}； //二分查找法。必须有前提：数组中的元素要有序。 public static int halfSeach_2(int[] arr,int key){ int min,max,mid; min = 0; max = arr.length-1; mid = (max+min)&gt;&gt;1; //(max+min)/2; while(arr[mid]!=key){ if(key&gt;arr[mid]){ min = mid + 1; } else if(key&lt;arr[mid]) max = mid - 1; if(max&lt;min) return -1; mid = (max+min)&gt;&gt;1; } return mid; } java分了5片内存。 1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。 栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )； 只要数据运算完成所在的区域结束，该数据就会被释放。 堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。 1：每一个实体都有内存首地址值。 2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。 3：垃圾回收机制。","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"pycharm安装步骤","slug":"pycharm安装步骤","date":"2019-11-03T02:15:31.000Z","updated":"2019-11-03T02:24:57.115Z","comments":true,"path":"2019/11/03/pycharm安装步骤/","link":"","permalink":"http://yoursite.com/2019/11/03/pycharm安装步骤/","excerpt":"","text":"1、首先去Pycharm官网，或者直接输入网址：http://www.jetbrains.com/pycharm/download/#section=windows，下载PyCharm安装包，根据自己电脑的操作系统进行选择，对于windows系统选择下图的框框所包含的安装包。Python环境搭建—安利Python小白的Python和Pycharm安装详细教程 2、选择Windows系统的专业版，将其下载到本地，如下图所示： 3、双击下载的安装包，进行安装，然后会弹出界面： 4、选择安装目录，Pycharm需要的内存较多，建议将其安装在D盘或者E盘，不建议放在系统盘C盘： 5、点击Next，进入下图的界面： Create Desktop Shortcut创建桌面快捷方式，一个32位，一个64位，小编的电脑是64位系统，所以选择64位。 勾选Create Associations是否关联文件，选择以后打开.py文件就会用PyCharm打开。 6、点击Next，进入下图： 默认安装即可，直接点击Install。 7、耐心的等待两分钟左右，如下图： 8、之后就会得到下面的安装完成的界面： 9、点击Finish，Pycharm安装完成。接下来对Pycharm进行配置，双击运行桌面上的Pycharm图标，进入下图界面： 选择Do not import settings，之后选择OK，进入下一步。 10、选择Accept，进入下一步： 11、进入激活界面，选择第二个License server，如下图所示： 之后在License server address中随意输入下面两个注册码中的任意一个即可，Pycharm新注册码1：http://idea.liyang.io或pycharm新注册码2：http://xidea.online，之后点击OK，便可以激活Pycharm了。 12、Pycharm激活后 END","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"win10系统Tomcat环境变量配置步骤","slug":"win10系统Tomcat环境变量配置步骤","date":"2019-11-03T01:58:55.000Z","updated":"2019-11-03T02:02:01.439Z","comments":true,"path":"2019/11/03/win10系统Tomcat环境变量配置步骤/","link":"","permalink":"http://yoursite.com/2019/11/03/win10系统Tomcat环境变量配置步骤/","excerpt":"","text":"一、环境的搭建 1、下载JAVA JDK，选择所要安装的目录安装。官网下载地址：http://java.sun.com/javase/downloads/index.jsp 2、设置环境变量。 在CLASSPATH环境变量后加上（即加上jdk安装路径下的tools.jar和dt.jar文件）： .;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar;path和JAVA_HOME的配置省略（Java初学者必备常识，不会百度“JDK的安装”）。接着下载解压Apache的Tomcat7.0.6，并将其放在自己想要的位置上。 随后在CLASSPATH环境变量中配置Tomcat（即加上Tomcat的lib库中的jsp-api.jar和servlet-api.jar文件） 1E:\\Tomcat\\lib\\jsp-api.jar;E:\\Tomcat\\lib\\servlet-api.jar;4. 在配置好环境后，在Tomcat的bin目录下找到startup.bat文件并双击打开，如果配置成功应该可以看见黑盒子里写的启动信息而不是闪退： 之后打开浏览器输入http://localhost:8080（注意startup.bat文件要一直开着），回车就看到服务器的信息了： 6.如果不能打开可能是端口冲突，需要修改端口。方法是打开Tomcat的conf目录下的server.xml文件，注意用记事本或notepad++等打开，将以下语句的port值8080改为自定义的端口号:","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"2019-10-31JDK的创建步骤","slug":"JDK的创建步骤","date":"2019-10-31T10:25:16.000Z","updated":"2019-10-31T10:31:19.916Z","comments":true,"path":"2019/10/31/JDK的创建步骤/","link":"","permalink":"http://yoursite.com/2019/10/31/JDK的创建步骤/","excerpt":"","text":"JDK的创建步骤1打开浏览器，输入JDK搜索，根据搜索结果下载安装包安装应用 2先接受协议，再根据自己的电脑下载相应的JDK版本，默认安装就行了。 3配置环境变量。找到安装路径，默认安装的一般都是在这个路径下C:\\Program Files\\Java\\jdk1.8.0_77 4然后点击电脑开机键，打开控制面板 5然后点击系统安全，打开进入 6点击系统 7点击“高级系统设置” 8点击高级中的“环境变量” 9在下面的系统变量中点击“新建” 10新建JAVA_HOME、CLASSPATH这两个项，最后在path中添加上去就完成了 11新建CLASSPATH，变量值 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar，注意前面有个点的 12将这两个变量加到path里面，直接在后面添加 ;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin，注意前面要有个分号“;” 13变量操作界面点击确定关闭 14系统高级设置页面点击“确定”关闭 15两个变量配置好了，到时直接可以在控制台编译运行Java文件，运行cmd查看Java环境是否配好。 16输入javac，按回车键，出现下面这些说明编译环境配好了 17再输入java，按回车键，出现下面这些，说明运行环境也好了。 END","categories":[],"tags":[]},{"title":"python知识点总结","slug":"python知识点总结","date":"2019-10-31T09:46:49.000Z","updated":"2019-10-31T09:48:18.950Z","comments":true,"path":"2019/10/31/python知识点总结/","link":"","permalink":"http://yoursite.com/2019/10/31/python知识点总结/","excerpt":"","text":"1、Python的两种编程方式：交互式（随输随运行）和文件式（主要方式；批量运行出结果） 2、一切皆对象，每个对象由标识（id()）、类型（type()）和值（print()）标识。 3、Python采用基于值的内存管理,不同变量赋值为同一个值，ID一样，但是只适用范围在-5至256的整数和短字符串。 4、内置函数（BIF），68个，查看方式：dir(builtins)分类：数值数据类型：int,float,complex,bool,decimal,fractions序列数据类型：字符串（string）、列表（list）、元祖（tuple）、bytes、bytearray集合数据类型：set、frozenset字典数据类型：dict不可变的数据类型：数值Number、字符串String、元祖Tuple可变的数据类型：列表List、字典Dict、集合Set 5、二进制：0b/0B开头八进制：0o/0O开头十六进制;0x/0X开头 6、数值运算函数：abs(x)：绝对值 ；divmod(x,y)：商余 ；pow(x,y,z)：幂余（(x**y)%z） ；round(x,d)：四舍五入d位 ；max/min ； int(x) /float(x) /complex(x) 7、math库：常数：math.pi ；math.fabs(x)：绝对值 ；math.fmod(x,y)：x%y ；math.ceil(x)：向上取整，返回不小于x的最小整数 ；math.floor(x)：向下取整，返回不大于x的最大整数 ；math.modf(x)：返回x的小数和整数部分 ；math.trunc(x)：返回x的整数部分 8、浮点数类型：0.1 + 0.2不等于 0.3 ，浮点数有小尾数。看是否等于可以用round（）函数帮助去小尾数。 9、类型间混合运算：整数 -&gt; 浮点数 -&gt; 复数 10、布尔数据类型（bool）包含两个值-&gt;True（真–1）或假（False–0）。如果表达式的结果为数值类型的0、空字符串（“”）、空元祖（）、空列表[]、空字典{}，则其布尔值为false（假），否则为true（真）。 11、逻辑运算符：and、or、nota and b等于a if not a else b ； a or b 等于a if a else b。not一定会返回true或false；and和or不一定。 12、运算优先级（由高到低）**（指数）&gt; +x.-x（正负号）&gt; *./.%（乘。除。取余）&gt; +. -（加。减）&gt; &amp;(与）&gt; ^（或）&gt; \\（非）&gt;比较大小&gt; not（非）&gt; and（与）&gt;or（或）&gt; lambda表达式 13、序列型数据（1）序列的索引s[i]：如果索引下标越界，导致IndexError；如果索引下标不是整数，导致TypeError。（2）序列的切片（截取序列s的一部分）：顾头不顾尾。（3）序列的加：x + y：连接两个序列； 序列的乘（复制）：x * n：复制n次序列x ；（4）判断子串：x in s ：返回True/False ； s.count(x)：返回x在s中出现的次数 ； s.index(x,i,j)：返回x在s（范围[i,j]）中第一次出现的索引位置。（5）序列的排序：sorted(s, key=None,reverse=False)。reverse为false是为升序，为true时为倒序。返回结果为一个列表。（6）序列的拆封赋值：当变量个数和序列长度相等时，一一对应赋值。如a,b = (1,2)即a = 1,b = 2。不等则导致ValueError。或使用变量（将多个值作为整体赋给变量）或使用临时变量‘_’ 14、字符串类型 比较字符ASCII码值的大小：空格&lt;数字&lt;大写字母&lt;小写字母Unicode变字符：chr(u) ；字符变Unicode：ord(x)format（）方法的格式控制：（1）槽{序号}的使用（2）{参数序号：格式控制标记}，格式控制标记包括：填充、对齐（分别用&lt;、&gt;、^表示左、右和居中对齐）、宽度、精度、类型（b=二进制，c=Unicode,d=十进制，o=八进制，xX=十六进制）。（3）字符串的类型判断：str.isdigit()是否全为数字（0-9）；str.isalpha()是否全为字母；str.isal num()是否全为数字或字母；str.isspace()是否是空白（空格、制表符、换行符等）；str.isprintable()是否可打印（空格和没有东西是可以被打印的）；str.isidentifier()是否满足标识符定义规则（字母或下划线开头，只含数字、字母和下划线）（4）大小写转换：str.capitaiize()：转换为首字母大写，其余小写；str.title()各单词首字母大写。（5）对齐：居中str.center(长度，填充物) ；左对齐：ljust ；右对齐：rjust。填充：str.zfill(长度)相当于右对齐，前方补0。如果str前有正负号，则正负号也算长度，在正负号之后填充。移除：左右两边：str.strip(字符chars) ； 左边：str.lstrip() ；右边;rstrip（）（6）字符串的查找：find和indexstr.find(s):从左至右查找str中是否含s,有则返回第一次出现s的索引位置，否则返回-1str.index（x）：从左至右查找是否含有x，有则返回第一次出现的索引位置，没有则抛出ValueErrorstr.rfind()和str.rindex()就是从右至左查找。（7）字符串的替换：S.replace(old,new,count)。将S中的old替换为new，如果给定count，则只替换前count个old子串。（8）拆分/分割：S.split(分隔符sep,分割次数maxsplit), maxsplit = -1或不指定时，会从左向右搜索完整个字符串。S.rsplit()是从右往左。生成列表。S.partition(sep)，S.rpartition(sep)(从右往左搜索)。搜索S中的子串sep，并从第一个sep处分割，返回一个包含三个元素的元组 –&gt;（sep左边的部分，sep，sep右边的部分）。如果搜索不到sep，则返回中有两个元素为空，partition是后两个元素为空，rpartition是前两个为空。（9）连接组合：S.join（字符串对象）。 当对象为字符串字典时，结果是键的连接。 15、列表类型 列表list是可变对象，则对其增删改查不会改变其的id。除了list.copy().方法：（1）添加：list.appand(x)：将元素x添加到列表的尾部；list.extend(L)：将列表L中所有元素添加到列表的尾部；list.insert(index,x)：在列表指定位置index处添加元素x；（2）删除：list.remove(x)：删除列表中首次出现的元素x；list.pop(kediedai[index])：删除并返回指定位置的元素（可以理解为挖取出），list为空就抛IndexError异常；list.clear()：删除列表中所有元素，但保留列表对象。（3）排序：list.reverse()：倒序；list.sort()：排序（正或倒）；（4）其他：list.index(x)：返回值为x首次出现的下标；list.count(x)：返回x的出现总次数；list.copy() ：返回列表对象的浅拷贝。很厉害！！它可以改变列表的ID！浅拷贝——只拷贝一层。如果拷贝对象只有一层，那么同b = a[:]，两个变量相互独立的。但如果拷贝对象只有一层，就会有影响，会跟着改变。（详见例题）！！列表推导式：[新元素表达式 for 临时变量 in 可迭代对象 if 条件表达式] 16、集合类型集合中的元素没有顺序，且不重复。集合set是可变的，用大括号表示。但是{}表示空字典；set()表示空集合，用set（）创建集合时，会将元素一个一个拆开，如’hello’变成’h’,‘e’,‘l’,‘l’,‘o’。集合中元素要是固定数据类型：整数、浮点数、字符串、元组等。不可为可变的列表、字典、集合。利用集合过滤掉重复的元素。4种基本操作：交（&amp;）、并（|）、差（-）、补（^）S.add() ;S.clear() ;S.copy() ; S.remove() ;len(S) ;x (not)in S ;**S.pop()：随机返回S中的一个元素，如果S为空，产生KeyError.(区分list.pop([index]))特有的：S.discard(X)；如果x在S中，移除x，不在，不报错。主要三大用途：成员关系测试、元素去重、删除数据项。 17、字典类型（映射）{建（key）：值（value）}。键不能重复，且是不可变对象。值可变。元素没有顺序。创建一个空字典：dict（） ；创建字典：dict(‘a’=1,‘b’=2)/dict(‘a’:1,‘b’:2)/dict((‘a’,1),(‘b’,2))查找值：Dict[key] ；修改键值：dict[key] = new_value ；增添新键值：dict[new_key] = new_value .D.keys()：返回所有键的列表,如dict_keys([‘a’, ‘b’, ‘c’])；D.values()：返回所有值的列表,如dict_values([1, 2, 3])；D.items()：返回所有的键值对的列表,如dict_items([(‘a’, 1), (‘b’, 2), (‘c’, 3)])；D.get(key,v)：键存在则返回相应值，否则返回None（自定义了v时，返回v的内容）;D.pop(key.value)：键存在则返回相应值，同时删除键值对，否则返回None；D.popitem()：随机取出一个键值对，以元组（key，value）形式返回；D.setdefault(k,v)：如果键k存在，返回对应值，否则添加项目k = v,v默认为None；D.update(dict)：更新或添加键值对；D.clear()：删除所有的键值对；del.D[key]：删除key对应的键值对。如果key不存在，则抛出KeyError。 遍历：for 变量名 in 字典名： 18、可变与不可变（关于值）可变：列表（有序）、集合（无序）、字典（无序）不可变：字符串（有序）、元组（有序）Python是基于值的内存管理方式，举例：a=[1,2,3],b=[1,2,3]，a==b成立。 但是id(a)与id(b)不相等，id(a[0])==id(b[0])成立。总结就是关乎值的就相等什么叫可变？即值是可变的，但id是固定不变的。例如可变的列表，修改列表L中的一个元素的值，列表L的id是不变的。不管是可变还是不可变的序列类型：（1）分片必定产生新的序列；（2）“+”号在等号右边（L=L+[i]），必定产生新的序列。然后将新的序列地址赋予给等号左边的变量。（每一次执行时都会将原列表复制一次，L指向新列表，并在新列表中加入新元素）对三种列表添加方法进行总结：（1）L=L+[i]在每一次执行时都会将原列表复制一次，L指向新列表，并在新列表中加入新元素。（2）L.append(i)只是将新元素直接添加到原列表中，不会产生新列表。（3）L+=[i]的执行效果和L.append(i)类似，也是在原列表中直接添加元素，不会复制原列表。b = a VS b = a[:]b = a时，b就是跟着a变化，并且a与b的id一样。b = a[:]时，b与a是独立的整体，id就不同，只不过指向了同一个值。对a做修改（增删改查），对b没有影响。 19、程序的三种基本结构：顺序结构、·分支结构（if-else、elif）、·循环结构（遍历：for…in、条件：while。循环控制：break/continue）。异常值处理：try-except。二分支结构简单语法：表达式1 if 条件 else 表达式2循环结构分遍历循环（for）和无限循环（while）：遍历循环：for 循环变量 in 遍历结构：语句块（从遍历结构逐一提取元素，放在循环变量中，对每一个提取出的元素执行一次语句块。）无限循环：while 条件：语句块。判断条件为True就一直循环，为false时魂环结束，执行与while同级别缩进的后续语句。break用于结束当前循环，如果有两层循环，break用于跳出最内层for或while循环，脱离该循环后程序从循环后代码继续执行；continue用来结束当前循环的当次循环过程，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。当有输入要求时，可运用异常值处理try：except： 20、函数（1）形参与实参：定义函数时的参数是形参，调用函数时的参数是实参。（2）参数传递的方法：位置参数、默认值参数、关键字参数、命名关键字参数。。。位置参数：按位置顺序传递参数值，位置参数要在所有参数之前，是第一个参数；关键字参数：关键字参数就是在调用函数，传入实参时指定形参的变量名。关键字不用遵守位置的对应关系。参数之间的顺序可以任意调整。关键字传递可以和位置传递混用。但位置参数要在关键字参数之前。举例：def hello(name,age = 11,gender = ‘F’):（age = 11,gender = ‘F’就是关键字参数）。举例：def hello(name,age = 11,gender = ‘F’):（age = 11,gender = ‘F’就是关键字参数）默认值参数：定义参数时已经给定值，一般参数为不可变对象，（如果为可变的空列表，可用于装位置参数）；可变数量参数：args、kw带有星号的可变参数只能出现在参数列表的后面。调用时，参数被当作元组类型传递到函数中。(如： def func(*args): -&gt; func(10,20))带双星号（）的参数，在使用时必须指定参数值，使用key=value这种形式，只能出现在参数列表的最后。调用时，kw后的那些参数被当作字典类型传递到函数中。（如：def func(kw): -&gt; func(a=10,b=20)）强制命名参数：参数带星号或者就是一个星号（def f(*c或,a,b,c)），强制命令参数c 的含义是它后面的参数必须用实名调用，即必须用 a = … , b = … 来调用，不能只写值。Python中只有函数，函数是有返回值的，*如果没有return，默认返回None。**return返回多个值时，多个值以元组形式保存。 21、比较（1）list.sort（）与全局sorted（）list.sort(key = None,reverse = False)是列表内置排序方法。但其返回值为None（x.sort()的结果、print（x.sort()）、x = x.sort()后x的结果都是None）,只有当文字说“执行语句x.sort（），x的值为”，x.sort（）作用的结果，需要通过打印被作用的列表才可以查看结果。true是倒序，false是正序。sorted（）：Python内置方法。返回新的列表。（2）list.reverse（）和reversed（）list.reverse()返回的是None，其作用的结果，需要通过打印被作用的列表才可以查看结果。reversed()：内置方法。经过reversed（）作用之后，返回的是一个吧序列值经过倒序的迭代器，所以，需要通过遍历或list、tuple或next（）方法，才能获得作用后的值。（3）字符串的查找：find和indexstr.find(s):从左至右查找str中是否含s,有则返回第一次出现s的索引位置，否则返回-1str.index（x）：从左至右查找是否含有x，有则返回第一次出现的索引位置，没有则抛出ValueErrorstr.rfind()和str.rindex()就是从右至左查找。 22、函数变量的作用域（1）局部变量、全局变量、globalglobal：用于在函数中直接修改全局变量的值。（2）内嵌函数内嵌函数的作用域仅限其所在的函数体内。如果要在内部函数中修改外部函数中的局部变量的值，使用nonlocal关键字。 END","categories":[],"tags":[]},{"title":"JAVA汉诺塔问题","slug":"JAVA汉诺塔问题","date":"2019-10-31T03:49:56.000Z","updated":"2019-10-31T03:51:52.768Z","comments":true,"path":"2019/10/31/JAVA汉诺塔问题/","link":"","permalink":"http://yoursite.com/2019/10/31/JAVA汉诺塔问题/","excerpt":"","text":"汉诺塔问题：有三根柱子A,B,C，其中A上面有n个圆盘，从上至下圆盘逐渐增大，每次只能移动一个圆盘，并且规定大的圆盘不能叠放在小的圆盘上面，现在想要把A上面的n个圆盘全部都移动到C上面，输出移动的总步数以及移动的过程分析：//先求出移动的总步数1，假设g（n）表示n个圆盘时的移动总的步数，当n=1时，g(1)=1;2.现在可以把g(n)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B上面，相当于将n-1个圆盘从A移动到C，因此需要g(n-1)步； 2&gt;然后将剩下的最大的圆盘从A移动到C，需要1步； 3&gt;最后再将n-1个圆盘从B通过A移动到C上面，相当于将n-1个圆盘从A移动到C，因此也需要g(n-1)步； 因此可以得出递归关系式：g(n) = 2*g(n-1)+1;//现在我们在来求出移动的过程1.假设hm(m,a,b,c)表示将m个圆盘从a通过b移动到c的过程，假设mv(a,c)输出一次a到c的过程，即print a–&gt;c2.初始化hm，当m=1时，hm(1,a,b,c)=mv(a,c);3.可以把hm(m,a,b,c)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B，此时b和c进行互换，也就是 hm(m-1,a,c,b); 2&gt;然后将剩下的最大的圆盘从A移动到C，也就是hm(1,a,b,c); 3&gt;最后将n-1个圆盘从B通过A移动到C，此时b和a进行交换，也就是 hm(m-1,b,a,c); 最终得到过程的递归关系式：hm(m,a,b,c) = hm(m-1,a,c,b)+1+hm(m-1,b,a,c); 代码：public class test{public static void main(String[] args){ Scanner in = new Scanner(System.in); int n = in.nextInt(); test t = new test(); //获取总的步数 System.out.println(“需要移动的总步数为:” +t.getSum(n)); //获取移动的过程 t.hm(n,’a’,’b’,’c’); } //获取总步数 public int getSum(int n){ if(n == 1) return 1; return 2 * getSum(n-1) +1 ; } //获取移动的过程 public void hm(int m,char a,char b,char c){ if(m == 1) move(a,c); hm(m-1,a,c,b); move(a,c); hm(m-1,b,a,c); } //输出一次移动的过程 public void move(char a,char c){ System.out.print(a + “–&gt;” + c + “ “); } }","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2019-10-13T10:01:23.000Z","updated":"2019-10-13T10:02:53.057Z","comments":true,"path":"2019/10/13/第一篇博客/","link":"","permalink":"http://yoursite.com/2019/10/13/第一篇博客/","excerpt":"","text":"Javaoop总结1.类与对象 抽象的，泛指的，是指从某一类具有相同属性和方法的对象中抽取出来 class代表类 类的作用；实例化对象，方法，工具类 类中分两大块：属性（成员变量） 方法（成员方法） 类如何实例化对象？ new Person p = new Person(); p.name = “张三”; p.sex = “男”; p：对象名 Person p1 = new Person();2. 属性与方法 方法的调用：对象名.方法名 匿名对象调用方法：new 类().方法名 new Person().getA(); int c = new Person().getD(10, 20); //实参 System.out.println(c);3.static static 静态，static用来修饰属性、方法 用static修饰属性：共有的属性——实例化出来的对象，用static修饰的具有相同的值。 用static修饰方法：能通过类名直接调用 4.封装, oopd三大特征之一； 属性私有化，公开setter和getter方法； 单例模式 只能实例化一次； 实现单例式的三个步骤：第一：私有化构造方法 private 类名（）{ } 第二：公开一个代理方法 private static 类名 方法名（）{ 类名 d=null； if（count&lt;1）{ d=new 类名（）； count++; } return d; } 第三：私有化一个静态属性，用来统计new的个数 private static int count=0; 5.继承,oop三大特征之一 继承 会让两个类产生一种关系 父类-子类 父类：从子类中抽取出共同的属性和共同的方法，放到父类中， 然后让子类继承父类，那子类就具有父类的属性和方法 继承的关键词：extends 类的继承格式 class 父类 { } class 子类 extends 父类 { } (1)父类中私有的属性和方法，子类是不能继承的 (2)父类的构造方法，子类是不能继承的 (3)父类是跨包的，除public以外的都不能被继承super 子类用来访问父类的方法或者属性 super.方法 super.属性 super()只能放在子类的构造方法中，并且只能放在第一行 重写 子类重写父类的方法； 方法名 +快捷键 多态,oop三大特征之一 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性多态存在的三个必要条件继承重写父类引用指向子类对象向上转型子类向父类的转换&lt;父类型&gt; &lt;引用变量名&gt;=new&lt;子类型&gt;;向下转型父类型转换为子类型&lt;子类型&gt;&lt;引用变量名&gt;=(&lt;子类型&gt;）&lt;父类型的引用变量&gt;; 抽象 (1)抽象 abstract abstract能修饰什么？类，方法(2) 用abstract修饰类叫抽象类 特点：抽象类不能被实例化，但能被继承 (3)用abstract修饰的方法叫抽象方法 特点：1.抽象方法没有方法体 2.抽象方法必须放在抽象类中，抽象类中的方法不一定是抽象方法 3.抽象类被子类继承后，那么子类要重写父类中的抽象方法，除非子类也是抽象类 访问权限private (私有的) 默认 (友好的) protected (受保护的) public (公共的) 9.final (1)final修饰类中的属性或者变量 无论属性是基本类型还是引用类型，final所起的作用都是变量里面存放的“值”不能变。 (2)final修饰类中的方法 作用：可以被继承，但继承后不能被重写。 (3)final修饰类 作用：类不可以被继承。 10.接口（重点） 创建接口类 public interface 接口的声明语法格式 interface 接口名称 extends 其他的接口名 { // 声明变量 // 抽象方法 } 接口关键字： interface 类要实现接口：implements class 类名 extends 父类名 implements 接口，接口，…{ //类成员 } 接口中的方法全是抽象方法 接口中的方法全部要公开public 接口不能被实例化 接口可以被多实现 接口中的属性全部是静态常量","categories":[],"tags":[]},{"title":"Readers are welcome to browse","slug":"Readers-are-welcome-to-browse","date":"2019-10-10T10:19:43.000Z","updated":"2019-10-10T10:20:41.888Z","comments":true,"path":"2019/10/10/Readers-are-welcome-to-browse/","link":"","permalink":"http://yoursite.com/2019/10/10/Readers-are-welcome-to-browse/","excerpt":"","text":"public class HelloWorld { /* 第一个Java程序 * 它将打印字符串 Hello World */ public static void main(String []args) { System.out.println(“Hello World”); // 打印 Hello World }}","categories":[],"tags":[]},{"title":"post title with whitespace","slug":"post-title-with-whitespace","date":"2019-10-10T07:03:54.000Z","updated":"2019-10-10T09:56:19.604Z","comments":true,"path":"2019/10/10/post-title-with-whitespace/","link":"","permalink":"http://yoursite.com/2019/10/10/post-title-with-whitespace/","excerpt":"","text":"python","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-09T13:21:42.052Z","updated":"2019-10-09T13:21:42.052Z","comments":true,"path":"2019/10/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}