{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JS知识点总结","slug":"JS知识点总结","date":"2019-11-23T05:30:34.000Z","updated":"2019-11-23T05:32:53.626Z","comments":true,"path":"2019/11/23/JS知识点总结/","link":"","permalink":"http://yoursite.com/2019/11/23/JS知识点总结/","excerpt":"","text":"js知识点总结组成ECMAscript 基础语法 变量 数据类型 运算符 数组 函数 对象BOM 浏览器对象模型 window对象（获取浏览器宽高） history对象 location对象DOM 文档对象模型 轮播图 元素获取 操作属性 操作样式 节点 事件 时间对象作用：（运营在用户端浏览器） 数据验证 动态创建和删除元素 操作元素的内容和样式 模拟动画 创建cookie ajax 请求数据。。。。。。 JSON格式的数据处理 *特征：面向对象 基于[对象]和[事件驱动]的松散型 解释型语言 客户端脚本语言，实现用户交互 BOM： 浏览器对象模型完成窗口与窗口之间的通信，window对象是其核心对象，history【前进，后退，刷新】 是一个对象 使用【window.history】location【地址】DOM【】screen【屏幕】frames[真窗口]navigationwindow对象：属性1-1：获取浏览器宽高a.ie8及以上 window.innerWidth [获取浏览器宽度] window.innerHeight [获取浏览器高度]b.ie8以下 document.documentElement.ClientWidth [宽度] document.documentElement.ClientHeight 【高度】1-2： 重新获取浏览器宽高 window.onreset=function () { NewW=window.innerWidth; NewH=window.innerHeight;}1-3：重新设置浏览器大小​ window.onresize=function（）{​ }1-4：浏览器滚动事件​ window.onscroll=function （）{​ }2.浏览器左上角距离屏幕左上角的偏移量 window.screenTop [垂直偏移量]window.screenLeft [水平偏移量]注意：因为window是核心，可以省略window不写方法alert() 弹出框prompt() 输入框confirm() 提示框，返回true或flaseclose() 关闭页面open(“url”) 打开页面（“打开的页面的路径【根据本html位置的相对路径】”） open(“url”,””,”width=300,height=200”);setInterval（fn，毫秒数）：隔毫秒数重复不断的执行一个函数fn方法1 let t =setInterval(fn,3000) function fn(){​ }方法2 setInterval(function(){​ },1000)clearInterval（t）：清除setInterval的时间函数 let t =setInterval(fn,3000)function fn(){ }clearInterval（t）setTimeout（fn，1000） 隔一定的时间只执行一次函数cleanTimeout（t） 清除时间函数 【用法同上】获取表单的值 对象.value=​清空=“”history对象属性：history.length 用来显示历史记录的长度方法history.forward() 前进history.back()后退history.go(0) 刷新 【1 前进，-1后退；不常用】location对象属性：设计获取当前页面的地址location.href=“ ” 设置或获取页面地址 设置新值location.host：主机名+端口号location.hostname：主机名location.port：端口号location.protocol：协议location.pathname： 路径location.search： ？后面的查询【搜索】字段方法location.reload( ) 重新加载location.replace（”网页.html”） 页面替换，不会增加历史记录location.assign（“网页.html”） 页面替换， 能够增加历史记录 DOM（文档对象模型）document object model获取元素获取body：document.body获取html：document.documentElement 获取id名的元素：let 变量=document.getElementById(“id名”) 例子： let box=document.getElementById(“id名”) 获取class名的元素[得到的是集合，可以通过键名访问] let 对象=document.getElementsByClassName（“class名”） 通过遍历改变样式集合通过单个下表改变，不能全部用class名同时改变3. 获取标签名的元素[得到的是集合，可以通过键名访问] let 对象=document.getElementsByTagName（“标签名”）4.给对象加类 标签加1个类名 对象.className=“类名”div加多个类名 对象.className=“类名1 类名2 ”5.指定范围的多层级获取【集合】 ​ 多楼层获取 let box=document.getElementClassName(\"box\"); let box1=box.getElementClassName(\"box1\"); let box2=box1.getElementClassName(\"box2\") 6.获取选择器选中的元素 let liss=document.querySelector(“【选择器】”); 获取选择器选中的第一个元素let lis=document.querySelectorAll(“【选择器】”); 获取选择器选中的全部元素【集合】【下标或者foreach遍历】7.属性选择器 let con = document.querySelector(“[name=con]”)操作样式获取样式获取行内样式 对象.style.样式名获取通用的样式【css和行内】 getComputedStyle(对象,null).样式名设置行内样式 对象.style.样式名=“样式值”对象.style=“background：red；border-radius：50%”批量操作类名 对象.className=”class类名”对象.className=“ ”；对象.classList.add（“”） 添加类对象.classList.remove（“”） 删除类对象.classList.toggle（“”） 切换类​对象.id=”id名”​外部定义一个样式，加到对象身上，参考第四点操作属性操作标准属性已知的，系统自带 对象.属性例子 ： img.src自定义属性获取 对象.getAttrbutte(“name”)设置 对象.setAttrbutte(“name”,”value”)操作内容innerText：不能识别html的标签对innerHTML: 可以识别html的标签对 对象.innerText=“内容”对象.innerHTML=“内容”添加事件对象.对象事件=function（）{}元素的尺寸和位置对象.offsetWidth:获取元素的真实宽度对象.offsetHeight:获取元素的真实高度对象.offsetTop：对象的上边框距离具有定位的父元素的内边框的垂直距离对象.offsetLeft：对象的左边框距离具有定位的父元素的内边框的水平距离对象.scrollTop：有滚动条的元素，浏览器滚动时在垂直方向的拉动距离 body的兼容document.body.scrollTop || document.documentElement.scrollTop 对象.scrollLeft：有滚动条的元素，浏览器在滚动时在水平方向的拉动距离动态创建标签let div=document.createElement（“标签名”）创建的元素放到也面中：document.body.appendChild（div）父元素.appendChild（子元素） 引入JS 外部引入方式 内部引入方式（在html页面中放入srcipt标签，和body同级） 放在事件后 文字等或事件 ​ 注意： ~js的几种引入方式是相互关联的，可以相互操作与访问 ~外部js中不能添加srcipt标签对 ~嵌入式的js中不能添加src属性 引入js的执行 将srcipt标签对放最最后 在.js文档中加入 window.onload=function（）{ 需要执行的js代码块 }输出工具 弹出框：alter(‘ ‘); 数字可加可不加’ ‘;输出到控制台：console.log(‘输出到控制台’);输出到html页面中[可以识别html的标签对，即解释为html语言]：document.write(‘输出到html页面中 ‘);输入工具 弹出框输入：var num=prompt(“提示文本”,[默认值])；提示工具 confirm(“提示内容”)；confirm返回值为true和false注释 单行注释： ctrl+？或者/ //块注释： ctrl+shift+/或者？ /* 块 */拼接 用“+”拼接 模板字符串（es6）：&lt;td&gt;${i}-${j}&lt;/td&gt;; 拼接部分用``括起来，变量用 ${变量}识别空格，换行等变量一个容器，存储数据变量的声明：var:let:let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效 适用于for循环 先声明，在使用 不允许在相同作用域内重复声明同一个变量。 let可以识别块级作用域 不存在变量提升（先访问后声明） 报错：没有定义const声明一个只读的常量。一旦声明，常量的值就不能改变。声明常量的同时进行赋值，不赋值就会报错可以识别块级作用域不能重复声明不存在变量提升【先访问在声明】 PI；命名规范：数字。字母。下划线组成不能以数字开头区分大小写不能以关键字（js中已经用到的）命名不能以保留字（js中将来会用到的）命名有意义遵循的规则：首字母大写 （Array String Obiect） ；驼峰命名法 （getElementByld）赋值先声明再赋值 var num;num=10;声明的同时赋值 var num=10;一次性声明多个变量，再赋值 var a,b,c;a=1,b=2;c=3;一次性声明多个变量同时复制 var a=1,b=2,c=3;注意事项：变量要先声明再访问，变量的默认值是undefined新值可以覆盖旧值变量可以用var关键字重新声明不用var关键字声明时必须给变量赋值，并且为全局变量，先访问后声明变量，值为undefined：js执行时先预解析（即识别var 和function声明的变量，不赋值），在解析，一句一句执行。数据类型根据在内存中的存储位置划分。基本数据类型存放在栈中，引用数据类型存放在堆中（指针存放在栈中，内容存放在堆中 ）基本数据类型undefinednull 【空占位符】string 【也是对象】模板字符串 字符编码 ASCII utf-8 unicode【万国码】 gb2312​ 转义字符： \\ \\n[换行] \\r \\t[制表符] &#39; \\ “” let 对象=new String（“ ”）；编码对象.charCodeAt(2) 返回第2个位置的字符编码String.fromCharCode（字符编码） 解码​查找元素对象.charAt(0) 字符串的第0个位置的元素【查找字符】​查找下标对象.indexOf（“ ”） 查找对应字符的下标，如果有返回下标，如果没有，返回-1【第一个字符开始的下标】对象.lastIndexOf（“”） 倒着看查找，倒序看如果有返回下标，如果没有，返回-1【第一个字符开始的下标】​对象.search（“”） 正则：有返回0；没有返回-1；对象.match（“”） 有的话，返回数组【返回值，下标，包含返回值的数组，】 没有 返回null​字符串的截取：【返回新值，不改变原内容】对象.substr（开始下标，【截取的长度】）对象.substring（开始下标，结束的下标），从开始下标开始到结束下标之前，不取到结束的下标对象.slice（开始下标，结束的下标），从开始下标开始到结束下标之前，不取到结束的下标【数组的方法】​字符串大小写【转换】let str=”AbCdEf”;str.toLowerCase() 转换为小写str.toUpperCase() 转换为大写​替换：str.replace（“山”，“闪”）；​转换【字符串转换数组】let str=“1,2,3,4,5,6”；arr2=str.split（“，”）；booleannumber 2e3=2*10^3 二进制： 0b开头八进制：以0o{0+字母o}开头，后跟0-7的数十六进制：以0x开头，后跟0-9或者a-fNaN:not a number 本来期望返回数值的操作，但并未返回数值的操作引用数据类型object（属性与方法的集合）数组，函数，对象深拷贝 let arr=【1,2,3,4】​let arr1；​arr1=arr； ：传址​arr1 和 arr具有相同地址浅拷贝： let arr=【1,2,3,4】​let arr1=【】​arr.foreach(function（value）{ arr1.push（value）})​判断变量的数据类型 ，其结果为字符串 typeof用法： var num=”5555”;typeof num;数据类型值情况typeof 的结果【看返回0 1代码的前三位】undefinedundefined undefinednullnull（空占位符） objectboolean 布尔型true false booleanstring 字符串型带” “或者’ ‘ stringnumber 数值型整数，小数，八进制，十六进制，十进制 object 运算符表达式：能够求值的语句算术运算符 / % ++var var++ –var var – 的特殊性 计算：操作对象是数值型拼接：操作对象含有字符串，字符串中进行运算时，用（）括起来自增与自减 ++var: ++在前，先算++，在执行本行的其他语句var++：++在后，先执行本行的其他语句，在算++关系运算符返回值为布尔值 ，即true或者false &lt; &gt;= &lt;= ==[等于] ===[全等于]–&gt; 数值和数据类型相同 !=[不等于] !==[不全等]如果比较的两个对象都是字符串[数字型，字符]，按照ASCII表对应的ASCII码比较，逐位相比如果比较的两个对象都是数值，直接比大小如果一个操作对象是字符串，另一个是操作对象是数值，先尝试将字符串转换为数字，如果转换成功，按照数字比较大小；如果转换不成，则返回false1==true； 0==false ； ==数值相同=== 数值和数据类型相同undefined=null赋值运算符 = +=[num+=10 等价于 num=num+10] -= *= /= %=逻辑运算符[与或非]测量值与变量之间的逻辑关系假：0、false undefined null NaN “ ”【空字符串】真：其余为真&amp;&amp;与||或！非【用来取反】ABA &amp;&amp; BA || B!Atruetruetruetruefalsetruefalsefalsetruefalsefalsetruefalsetruetruefalsefalsefalsefalsetrue返回值：第一步：先看与或非两边的真假第二步：在看返回的真假的内容&amp;&amp; 同真为真，返回第一个假值 【遵循短路原则：看到假值，后边的不看了】；全为真，返回最后一个真值|| 同假为假，返回第一个真值 【遵循短路原则：看到真值，后边的不看了】；全为假，返回最后一个假值! 取反；返回值只有ture或false运算符的优先级算术&gt;关系运算符&gt;逻辑运算符 三元运算符： 表达式?为真的执行语句：为假的执行语句 【类似if else】一元运算符： typeof + - new特殊运算符： （） .流程控制代码按照指定条件的执行顺序顺序结构分支结构循环结构顺序结构语句按照从上到下的顺序进行执行循环结构当满足条件时，重复不断的执行一段代码for循环：明确知道次数 for(初始条件；终止条件；步进值){ }swith循环 switch(表达式【能够求值的语句】){ case 值1【表达式能取到的值】：语句1；break； case 值2【表达式能取到的值】：语句2；break； … default: 语句；}while循环 while(条件){ 满足条件时，执行语句；}​例子： var j=0； while(j&lt;5){ console.log(1); j++; }do while循环执行顺序先执行循环体，在执行判断语句 do{ 循环体；}while(条件)​例子：var i=0;do{ console.log(1); i++;}(i&lt;5)​循环结束continue满足条件终止本次循环 ​break满足条件,终止整个循环 ​分支结构当条件成立时执行相应的语句单分支结构 if条件：if（表达式）{ 为真的执行语句【返回值为true执行的语句】}双分支 if条件：if（表达式）{ 为真的执行语句}else{ 为假的执行语句}多分支 if条件：if（表达式1）{ 表达式1成立时执行语句}else if(表达式2){ 表达式1不成立 但 表达式2成立时执行语句}else if(表达式3){ 表达式1不成立且表达式2不成立【但】表达式3成立时执行语句}else{ 以上表达式都不成立时执行的语句}嵌套分支 if(){ if(){ } else{ }}else{​}数学方法取随机数 Math.random() ; (0-1)取整 向下取整【向左取整】： rgb=Math.floor(Math.random());向上取整【向右取整】： rgb=Math.ceil(Math.random());次幂[x的y次幂] Math.pow(x,y)一维数组按照顺序排列的一组相关数据。特点：每一个数组元素都有一个特定的键名（即俗称的下标）[字符串类型]数组元素的默认值时undefined数组的声明[初始化数组]先声明后赋值 var arr=[]; arr[0]=89,arr[0]=”adc”,….;声明的同时赋值 var arr=[90,89,88,76,56];数组下标的范围访问数组元素，范围【0，n-1】数组的长度数组名.length; 例子： arr.length注意：数组的长度可变 arr=[90,89,88,76,56]; 可以随时添加元素，可跳着添加。如： arr[6]=”aaa”；数组元素可以时任意的数据类型 arr=[true,null,{name:},[1,2,3]]遍历数组元素访问数组的每一个元素 用for循环遍历数组 for(var i=0;i&lt;arr.length;i++){ arr.[i]; 即可访问arr的每个元素}2. 用for in循环遍历数组 for(var i in arr){ i; //代表arr的键名（下标） arr[i]; //元素}3.for of遍历元素 for（item of arr1）{ arr2.push（item）}4.foreach遍历数组 用法：arr.forEach(function (value，index){​}）value[名字随便起]:数组中的当前元素【必须有】index[名字随便起]:数组当前元素的下标【键名】【可选】清空数组arr.length=0二维数组声明： var arr=[[1,2.3],[“a”,”b”],[78,89];访问： arr[行][列]遍历 for(var i=0;i&lt;arr.length;i++){ for(var j=0;j&lt;arr[i].length;j++){ arr[i][j] }}数组身上的方法向数组的后面插入一个或多个元素（.push） arr.push(需要插入的内容)；删除数组最后一位：.pop arr.pop（）在数组之前插入: .unshift arr.unshift(“”)在数组之前删除一位：.shift arr.shift（）万能的插入和删除：.splice（） arr.splice(开始的位置,长度，“再删除的位置加入的元素1”，“再删除的位置加入的元素2”，…);不想删除，让其长度为0；可以返回删除的值：arr.splice（）是否包含某个元素： .includes arr.includes（“被包含的内容”）;截取元素： .slice arr.slice（2,5）：截取第2位开始的。第5位之前的连接多个数组：.concat arr.concat([数组1],[数组2])数组的取反：.reverse arr.reverse()把数组转换为字符串: .join arr.join（“连接符（-/，/；/..）”）排序：.sort arr.sort（（x，y）=&gt; x-y）; 升序arr.sort（（x，y）=&gt; y-x）; 降序​arr.sort(function（x，y）{ return x-y})​查找： .find（） arr.find(item=&gt;item&gt;7) 找到第一个比7大的数arr.find(item=&gt;item%2==0) 找第一个偶数​arr.find（function(item){ return item%2==0;}）查找第一个符合条件的下标： .findIndex（） let index= arr.findIndex(function(item){ return item &gt; top //返回布尔值，为真时返回下标 })返回符合条件的真假值：.some() arr.some（item=&gt;item&gt;8）;返回每一个符合条件的元素：.every() arr.every（item=&gt;item&lt;10）;筛选符合条件的：.filter() arr.filter（item=&gt;item%2==0）; 返回新数组遍历数组（.forEach）arr.forEach 用法：arr.forEach(function (value，index){​}）value[名字随便起]:数组中的当前元素【必须有】index[名字随便起]:数组当前元素的下标【键名】【可选】处理每个元素:.map arr.map（item=&gt;{return item*10}） //让数组中的每个元素都执行一个函数，返回一个新数组全部方法concat()连接两个或更多的数组，并返回结果。copyWithin()从数组的指定位置拷贝元素到数组的另一个指定位置中。every()检测数值元素的每个元素是否都符合条件。fill()使用一个固定值来填充数组。filter()检测数值元素，并返回符合条件所有元素的数组。find()返回符合传入测试（函数）条件的数组元素。findIndex()返回符合传入测试（函数）条件的数组元素索引。forEach()数组每个元素都执行一次回调函数。indexOf()搜索数组中的元素，并返回它所在的位置。join()把数组的所有元素放入一个字符串。lastIndexOf()返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。map()通过指定函数处理数组的每个元素，并返回处理后的数组。pop()删除数组的最后一个元素并返回删除的元素。push()向数组的末尾添加一个或更多元素，并返回新的长度。reduce()将数组元素计算为一个值（从左到右）。reduceRight()将数组元素计算为一个值（从右到左）。reverse()反转数组的元素顺序。shift()删除并返回数组的第一个元素。slice()选取数组的的一部分，并返回一个新数组。some()检测数组元素中是否有元素符合指定条件。sort()对数组的元素进行排序。splice()从数组中添加或删除元素。toString()把数组转换为字符串，并返回结果。unshift()向数组的开头添加一个或更多元素，并返回新的长度。valueOf()返回数组对象的原始值。函数把实现某一特定功能的代码块封装起来，并能够重复调用定义函数 基本语法（function关键字）【调用可以在声明前，也可以在声明后】 function 函数名（形参1，形参2,….）{ 函数体； return 返回值；【可有可无】 《并不向用户显示，仅是调用的数的值》}2. 字面量，自变量【必须先声明在调用】【预解析】 var 变量=function (参数){ 函数体；}调用 变量（）3. 对象的方式【实例化对象】 let aa=new Function（“a”，“b”，“alter（a+b）”）调用 aa（10,20）匿名函数定义与调用 (function (){ })()​定义：(function (){ }调用【一般在定义的时候就调用】：(function (){ })()箭头函数 定义：let aa=()=&gt;console.log(123);let aa=(参数)=&gt;{ 多行函数体；}调用： aa(实参) 函数的调用 函数名（实参1，实参2，….） 自变量（） 自变量（参数1，参数2）参数能够动态改变函数体的变量，使函数更加灵活形参：定义函数使写在括号里的量。其作用为接收实参形参默认值的传递 if else分支结构 if(flag==undefined){ } else{​ } 三元运算符【用的多】 flag=flag==underfined？”&lt;”:flag 逻辑或||返回第一个真值【用的多】 flag=flag||”&lt;” 定义形参的时候直接赋值:当形参为undefined时给形参默认值 flag=25555;实参：函数调用时写在括号中的值。其作用为给形参传值全部的实参由arguments接收参数传递参数可以是任意的数据类型参数的传递按顺序传递：从左到右形参=实参 ：一一对应的传递形参&gt;实参：多余的形参赋值为undefined形参&lt;实参：实参由arguments对象来接收剩余参数声明： …rest【为数组】 function 函数名(形参1,…rest){ 函数体；}rest和arguments对象的区别 rest接收多余的参数，arguments接收全部的实参 rest是数组，能够使用数组的方法，键名从0开始；arguments对象类似数组，不能使用数组的方法函数的返回值：returnreturn 终止函数。遇到return，后面都不执行返回值可以是任意的数据类型一个函数内部可以有多条return分支语句，但最终只执行一条return语句只能返回一个值回调函数把一个函数的指针（函数名）作为参数传递给另一个函数，当指针调用函数时，这个函数叫做回调函数【高阶函数】：形参高阶函数和 返回值高阶函数指针类型 function math(num1,num2,callback) { return callback(num1,num2); } function add(num1,num2) { return num1+num2; } function sub(num1,num2) { return num1-num2; } function mult(num1,num2) { return num1*num2; } function div(num1,num2) { return num1/num2; } document.write(math(1,2,div));函数类型 foreacharguments对象用来接收参数的详细信息每声明一个函数，在其内部自动生成arguments对象arguments对象只在函数内部起作用不是数组类似数组，可以用键名遍历数组（arguments[i]），其长度为arguments.length不能用数组身上的方法闭包函数内部的函数调用外部的函数的【变量】; function fn1(){ let a=”456”; function fn2(){ console.log(a) } return fn2;}​let fn2=fn1();fn2()// js中没有函数的重载：传的参数不同，执行不同的函数 作用域变量起作用的范围局部作用域优先于全局作用域[作用域链]全局作用域 在整个js中都能访问的变量，凡是进行修改，变量的值就会改变 类型【情况】 在函数外部用var声明的变量，即拥有全局作用域 不用var声明，但是赋值的变量就是全局变量，即拥有全局作用域；局部作用域 类型【情况】 形参是局部变量，即拥有局部作用域 在函数内部用var关键字声明的变量，也是局部变量，即拥有局部的作用域。块级作用域 { 括起来的就是块级作用域；}内置顶层函数内置：ECMAscript自带的函数，本身就有；只要求知道如何让使用，不用关心如何封装顶层：在js代码中的任何位置都可以使用；escape()：将传进来的字符串进行编码 escape(“编码的内容”); 编码内容一般为中文unescape（）：对编码的字符串进行解码 unescape(“字符串的编码”)Boolean（）：将其余数据类型转换为布尔型String（）：将任意数据类型转换为字符串型Number（）：将其余数据类型转换为数值型情况 null：0 “”：0 “ ”：0 false：0 true：1 undefined：NaN 进制数转换为十进制 去掉没有意义的后导0和前导0 字符串： 规范的浮点数，数值型字符串parseInt（）：将字符串转换为整数第一个位置为字母 （+、-）号 空格转换不成功，转换为NaNparseFloat（）：将字符串转换为小数只能转换规范的浮点数转换不成功，返回NaNisNaN():值是否够转换为数值型能转换为数值型返回false不能转换为数值型返回true作用：数据类型转换强制类型转换隐式数据类型转换：算数运算符，逻辑运算符，条件语句（if，while等）对象 类概念类：一群具有相同特征的对象集合的描述对象：具体存在的类个体属性：对象基础信息的描述方法：对象功能的描述定义对象构造函数（类）,实例化对象 构造类 function 类名（color，price等其他形参）{ this.color=color； this.price=price； //实例化时，this指向实例化的对象 this.play=function（）{ } } 实例化对象 let 对象=new 类名(实参); 对象的属性【对象属性的添加】 对象.属性名=“属性值”； 访问：对象.属性名 / 对象【‘属性名’】 对象的方法【对象方法的添加】【方法是特殊的属性】 对象.方法名=function（）{}； 访问：对象.方法名（） 遍历【i代表的是属性名】 for（let i in 对象）{ i；//属性名，方法 对象【i】；//属性值 } 对象属性的增删改查： 增加： 对象.属性名=“属性值”； 删除： delete 对象.属性名 修改： 对象.属性名=“属性值” 查讯： 对象.属性名 ； 对象【‘属性名’】JSON [注意格式] 【可直接定义对象】 1.定义 let 对象={ 属性名：属性值， //属性名可以加引号，也可以不加引号 属性名：属性值， 方法名：function（）{​ }， 方法名：function（）{​ } }2.增删改查 增加： 对象.属性名=“属性值”； 删除： delete 对象.属性名 修改： 对象.属性名=“属性值” 查找： 对象.属性名 ； 对象【‘属性名’】3.遍历 for（let i in 对象）{ i；//属性名，方法 对象【i】；//属性值 }4.对象.constructor 返回 objectclass定义类，实例化对象重要的关键字[方法]constructor： 返回该对象的构造函数 使用： 对象.constructorinstanceof：判断函数是否为对象的构造函数？true：false； 使用 : 对象 instanceof 构造函数原型，原型链 最大的类：object:[prototype proto]生成人类：person：【proto prototype】 proto继承父类的prototype生成对象：xb【proto，prototype】 proto继承人类的prototypesing改变函数的指针 sing.call（xb，10,20）sing.apply（sb，【10,20】）sing.​将小白的say方法传给小红say=xh.saysay.call（xh）递归函数自己调用自己,必须有一个 出口 function fn（num）{ if（num==0）{ return 1; } else{ return num*fn(num-1) }} function fnn(arr){ let arr1=[] for(let i=0;i&lt;arr.length;i++){ if(typeof arr[i]==”object”){ arr1.push(fnn(arr[i])) } else{ arr1.push(arr[i]) } } return arr1; }console.log(fnn([0,[1,2],[2,3]]))节点：整个文档 元素【标签】 属性 文本 注释【节点】文档的节点 document.nodeName #documentdocument.nodeValue nulldocument.nodeType 9元素的节点 let box=documentquerySelector(“box”)box.nodeName 大写的标签名box.nodeValue nullbox.nodeType 1节点nodeName（名字）nodeValue（值）nodeType（节点类型）文档节点#documentnull9元素节点大写的标签名null1属性节点大写的属性名属性值2文本节点#text文本3注释节点#comment注释内容8节点的获取1.childNodes：子节点 document.childNodes[1].childNodes2.parendNode：父节点 let box=document.querySelector(“box”) ;​3.上一个兄弟节点：previousSibling box.previousSibling3.下一个兄弟节点：nextSibling box.nextSibling4.上一个兄弟元素节点：previousElementSibling box.previousElementSibling5.下一个兄弟元素节点：nextElementSibling box.nextElementSibling节点的方法创建元素节点let div=document.createElement(“div”)在最后插入节点let box=document.querySelector（“.box”）；box.appendChild（div）在之前插入节点.insertBefore(要插入的元素，插入位置之后的元素)let span=document.querySelector(“span”)box.insertBefore(span,div)创建文本节点let text=document.createTextNode（”必须有参数”）text.nodeValue=“这是span标签”span.appendChild(text)创建注释节点let comment1=document.createComment（“这是注释节点”）;box.appendChild(comment1);创建属性节点let attr=document.createAttribute(“id”);添加/设置属性节点.setAttribute(“name”,”value”);//添加属性box.setAttributeNode（attr）添加：append 删除：remove删除标签节点 ： box.removeChild(div)删除属性节点： box.removeChild(“属性名”)DOM（文档对象模型）document object model获取元素获取body：document.body获取html：document.documentElementDom对象 获取id名的元素： let 变量=document.getElementById(“id名”) 例子： let box=document.getElementById(“id名”)2.获取class名的元素[得到的是集合，可以通过键名访问] let 对象=document.getElementsByClassName（“class名”） 通过遍历改变样式集合通过单个下表改变，不能全部用class名同时改变3. 获取标签名的元素[得到的是集合，可以通过键名访问] let 对象=document.getElementsByTagName（“标签名”）4.给对象加类 标签加1个类名 对象.className=“类名”div加多个类名 对象.className=“类名1 类名2 ”5.指定范围的多层级获取【集合】 ​ 多楼层获取 let box=document.getElementClassName(\"box\"); let box1=box.getElementClassName(\"box1\"); let box2=box1.getElementClassName(\"box2\") 6.获取选择器选中的元素 let liss=document.querySelector(“【选择器】”); 获取选择器选中的第一个元素let lis=document.querySelectorAll(“【选择器】”); 获取选择器选中的全部元素【集合】【下标或者foreach遍历】7.属性选择器 let con = document.querySelector(“[name=con]”)操作样式获取样式获取行内样式 对象.style.样式名获取通用的样式【css和行内】 getComputedStyle(对象,null).样式名设置行内样式 对象.style.样式名=“样式值”对象.style=“background：red；border-radius：50%”批量操作类名 对象.className=”class类名”对象.className=“ ”；对象.classList.add（“”） 添加类对象.classList.remove（“”） 删除类对象.classList.toggle（“”） 切换类​对象.id=”id名”​外部定义一个样式，加到对象身上，参考第四点操作属性操作标准属性已知的，系统自带 对象.属性例子 ： img.src自定义属性获取 对象.getAttrbutte(“name”)设置 对象.setAttrbutte(“name”,”value”)操作内容innerText：不能识别html的标签对innerHTML: 可以识别html的标签对 对象.innerText=“内容”对象.innerHTML=“内容”添加事件对象.对象事件=function（）{}元素的尺寸和位置对象.offsetWidth:获取元素的真实宽度对象.offsetHeight:获取元素的真实高度对象.offsetTop：对象的上边框距离具有定位的父元素的内边框的垂直距离对象.offsetLeft：对象的左边框距离具有定位的父元素的内边框的水平距离对象.scrollTop：有滚动条的元素，浏览器滚动时在垂直方向的拉动距离 body的兼容document.body.scrollTop || document.documentElement.scrollTop 对象.scrollLeft：有滚动条的元素，浏览器在滚动时在水平方向的拉动距离动态创建标签let div=document.createElement（“标签名”）创建的元素放到也面中：document.body.appendChild（div）父元素.appendChild（子元素） BOM： 浏览器对象模型完成窗口与窗口之间的通信，window对象是其核心对象，history【前进，后退，刷新】 是一个对象 使用【window.history】location【地址】DOM【】screen【屏幕】frames[真窗口]navigationwindow对象：属性1-1：获取浏览器宽高 a.ie8及以上 window.innerWidth [获取浏览器宽度] window.innerHeight [获取浏览器高度]b.ie8以下 document.documentElement.ClientWidth [宽度] document.documentElement.ClientHeight 【高度】1-2： 重新获取浏览器宽高window.onreset=function () { NewW=window.innerWidth; NewH=window.innerHeight;} 1-3：重新设置浏览器大小window.onresize=function（）{ } 1-4：浏览器滚动事件window.onscroll=function （）{ } 2.浏览器左上角距离屏幕左上角的偏移量 window.screenTop [垂直偏移量]window.screenLeft [水平偏移量]注意：因为window是核心，可以省略window不写方法alert() 弹出框prompt() 输入框confirm() 提示框，返回true或flaseclose() 关闭页面open(“url”) 打开页面（“打开的页面的路径【根据本html位置的相对路径】”） open(“url”,””,”width=300,height=200”);setInterval（fn，毫秒数）：隔毫秒数重复不断的执行一个函数fn 方法1 let t =setInterval(fn,3000) function fn(){​ }方法2 setInterval(function(){​ },1000)clearInterval（t）：清除setInterval的时间函数 let t =setInterval(fn,3000)function fn(){ }clearInterval（t）setTimeout（fn，1000） 隔一定的时间只执行一次函数cleanTimeout（t） 清除时间函数 【用法同上】获取表单的值 对象.value=​清空=“”history对象属性：history.length 用来显示历史记录的长度方法history.forward() 前进history.back()后退history.go(0) 刷新 【1 前进，-1后退；不常用】location对象属性：设计获取当前页面的地址location.href=“ ” 设置或获取页面地址 设置新值location.host：主机名+端口号location.hostname：主机名location.port：端口号location.protocol：协议location.pathname： 路径location.search： ？后面的查询【搜索】字段方法location.reload( ) 重新加载location.replace（”网页.html”） 页面替换，不会增加历史记录location.assign（“网页.html”） 页面替换， 能够增加历史记录 事件事件的添加方式 节点.onclick=function（e）{​}只能添加一个 节点.addEventListener(“事件【click】”,事件处理程序，事件类型【布尔值】【可以不给】)可以添加多个事件 将事件加在元素身上， 在js中定义事件的函数 function 事件函数（）{ 函数体 } 事件的构成 事件源：谁去触发事件谁就是事件源 事件：鼠标事件/键盘事件 事件处理程序： 常用的web端事件 onclick：单击 ondblclick：双击 onmousedown：按下 onmouseup：抬起 onmousemove：鼠标移动 onmouseover：移入 onmouseout：移出 onmouseenter：移入 onmouseleave：移出 oncontextmenu：右击事件【默认事件】 对象.oncontextmenu=function(e){ e.preventDefault() //阻止浏览器默认右击行为}onmousewheel 滚轮滚动事件移动端事件ontouchstart：按下ontouchmove：移动ontouchend：抬起事件对象：用来保存事件触发时的信息 w3c ： 在事件处理程序的形参中ie ： 在window.event中​解决兼容性：let event=e || window.event鼠标事件对象常用的属性：clientX : 距离浏览器 X轴 的偏移量 【client设备】clientY：距离浏览器 Y 轴 的偏移量 从 浏览器的 哪个位置进来offsetX：距离事件源 X轴 的偏移量offsetY：距离事件源 Y轴 的偏移量 从 事件源的 哪个位置进来screenX：距离屏幕 X轴 的偏移量screenY：距离屏幕 Y轴 的偏移量 从 屏幕的 哪个位置进来键盘事件onkeydown 键盘按下onkeyup 键盘抬起onkeypress键盘按下：按下功能键ctrl shift alt delete esc等不会触发键盘事件对象常用的属性keyCode：键盘码ctrlKey：是否按下了ctrlshiftKey：是否按下了shiftaltKey：是否按下了altkey：键名表单事件oninput：输入事件onchange：内容发生改变，并且失去焦点onblur：失去焦点onfocus：获得焦点onsubmit：提交表单onselect：文本选中窗口事件onscroll：滚动事件onload：加载onresize：重新获取浏览器大小事件流当触发一个事件时，由这个事件的容器到整个文档都会按照特定的顺序依次进行触发顺序：子元素 -》 父元素 【具体的到不具体的】事件分类捕获型事件：true【大到小，不具体的事件源到具体的事件源】冒泡型事件：false【小到大，具体的事件源到不具体的事件源】浏览器执行事件的顺序：doc的捕获 html的捕获 body的捕获 具体元素的捕获 具体元素的冒泡 body的冒 泡html的冒泡 doc的冒泡 阻止事件流 w3c浏览器 box.addeventListener（“click”，function（event）{ let event=event|| window.event event.stopPropagation（） },false）ie浏览器 box.addeventListener（“click”，function（event）{ let event=event|| window.event event.stopPropagation（） event.returnValue=true； },false）事件委派event.target：目标事件源【记录】获取到的是元素/属性：类型：节点；点谁获取到谁ｅｖｅｎｔ．ｔａｒｇｅｔ．ｃｌａｓｓＮａｍｅ 事件源的类名 正则定义用来描述或者匹配一系列符合某种规则的字符串，规则可以自己定义作用数据验证内容检索内容替换内容过滤正则对象创建正则对象实例化对象 let reg = new RegExp(“正则表达式[即规则]”，”模式修正符”)必须传入字符串自变量，字面量 let reg=/正则表达式/模式修正符 ； (//代表定界符)正则对象常用的方法test（str） 检测正则对象是否能够匹配str ， 返回值 true || falseexec( str ) 检测正则对象是否能够匹配str，如果能够匹配，返回一个拥有特殊属性的数组，如果不能匹配，返回null let reg = new RegExp(“uek”,”gi”);let bool=reg.test(“www.sxuek.com&quot;); //bool=true​正则表达式原子原子：正则表达式最小的内容【只能匹配一位】\\d 匹配 0-9 ;\\D 匹配：除了0-9意外的字符\\w 匹配：数字、字母、下划线\\W 匹配：除了数字字母下划线以外的字符\\s 匹配：空白 \\n换行 \\r回车 \\t 制表符\\S 匹配：除了空白以外的字符\\b 单词的边界\\B 非单词边界 let str=“abc1”let reg=/\\w/g;reg.test(str)原子表【只匹配一个】定义： [ ] 匹配a-c let str=“abcdef1” let reg=/[a-c]/g; reg.test(str)匹配 [a-z] 匹配a-z匹配 [a-zA-Z] 匹配a-z和A-Z匹配 [a-zA-Z0-9] 匹配a-z和A-Z和0-9匹配 [a-zA-Z\\s] 匹配a-z和A-Z和空格元字符 . 代表所有的字符| 或者原子组相当于变量默认保存在内存中；可以使用\\1 \\2等方式依次引用（）中的内容（？： ）可以使原子组不在内存中存储，不可以调用 let str1=”山西优逸客”let str2=”陕西优逸客”let reg=/(山西|陕西)优逸客/g；reg.exec(str1) let str=”hello“let reg=/&lt;(div)&gt;hello&lt;/\\1&gt;/greg.exec(str);​let str=”div“ //没有变量名let reg=/&lt;(div)&gt;\\1&lt;/\\1&gt;/greg.exec(str);​let str=”山西优逸客-山西“let reg=/&lt;(div)&gt;(山西|陕西)优逸客-\\2&lt;/\\1&gt;/g​let reg=/&lt;(div)&gt;(?:山西|陕西)优逸客-\\2&lt;/\\1&gt;/g \\2不会被引用数量[手机号/身份证号] 0个或者多个 》=0 贪婪let phone=”18335219360”;let reg=/\\d*/greg.exec(phone) 1个或者多个 》=1 ？ 0个或者一个 吝啬 {11}限制长度为11{15，18} 长度为 15-18{6，} 长度为6以及以上 贪婪吝啬 +？ 变成吝啬*?+?{11，}？{11,20}？ 边界判断【限制长度】^ 以…开始$ 以…结束​let reg=/^(0351)-\\d{7}$/ let str1=”hello word”let reg=/o\\b/​模式修正符可以搭配使用 gi mi mg 先后顺序执行g 全局 global记录下标，下一个下标位置开始i 不区分大小写m 可以换行正则的使用场所正则对象str对象 中的 str.split（正则对象） 拆分 let str=”山西有一棵：1,2.3”str.split(/[: , .]/)str对象 中的 str.replace（正则对象） 替换 let str=”山西有课山西有了”str.replace（/（山西）/g，陕西）str对象 中的 str.search（正则对象） 查找 let str=”山西有课山西有了”str.search（/（山西|有一颗）/）常用的正则 用户名 /^[a-z0-9_-]{3,16}$/密码 /^[a-z0-9_-]{6,18}$/十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/电子邮箱 /^([a-z0-9_.-]+)@([\\da-z.-]+).([a-z.]{2,6})$//^[a-z\\d]+(.[a-z\\d]+)@(\\da-z?)+(.{1,2}[a-z]+)+$/URL /^(https?://)?([\\da-z.-]+).([a-z.]{2,6})([/\\w .-])/?$/IP 地址 /((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)//^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/HTML 标签 /^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;/\\1&gt;|\\s+/&gt;)$/删除代码\\注释 (?&lt;!http:|\\S)//.$Unicode编码中的汉字范围 /^[\\u2E80-\\u9FFF]+$/ 日期对象/函数 自定义时间let ay=new Date(“2018/8/8 12:00:00”)​let ay1=new Date(“12:00:00 2018/8/8”)​let ay2=new Date(“2018,0,8”) //月份从0开始获取当前格林尼治时间let now=new Date() //获取当前格林尼治时间now.setFullYear(2020) 设置年份now.setMonth(5) 6月份now.setDate(26) 26号now.setHours（12） 12时now.setMinutes(0) 分now.setSeconds（0） 秒now.setMilliseconds（0） 毫秒​获取世界协调时间【用法同上】now.setUTCFullYear()now.setUTCMonth（）now.setUTCDate（）now.setUTCHours（12） 12时now.setUTCMinutes(0) 分now.setUTCSeconds（0） 秒now.setUTCMilliseconds（0） 毫秒​​//获取时间now.getFullYear() //now.getUTCFullYear()now.getMonth（）+1now.getDate（）now.getDay() 星期now.getHours()now.getMinutes()now.getSeconds()now.getMilliseconds（0）​//获取毫秒数now.getTime() 1970.1.1.0的毫秒数时间案例 倒计时 jishi() setInterval(jishi,2000); function jishi(){ let arr=daoJiShi(); span9.forEach(function (value,index) { value.innerText=arr[index]; }) } function daoJiShi() { let arr=[]; let now=new Date(); let future=new Date(2018,6,26,18); let times=future.getTime(); //未来的毫秒数 let time=now.getTime();//现在的毫秒数 let juXianZai=Math.floor((times-time)/1000); //2018.9.1到现在时间的秒数 let Month=Math.floor(juXianZai/(30246060)); arr.push(Month); juXianZai=juXianZai%(30246060);​ let Day=Math.floor(juXianZai/(246060)); arr.push(Day); juXianZai=juXianZai%(246060);​ let shi=Math.floor(juXianZai/(6060)); if(shi&gt;0 &amp; shi&lt;9){ shi=”0”+shi; } arr.push(shi); juXianZai=juXianZai%(6060);​ let fen=Math.floor(juXianZai/(60)); if(fen&gt;0 &amp; fen&lt;9){ fen =”0”+fen; } arr.push(fen); let miao=Math.floor(juXianZai%60); if(miao&gt;0 &amp; miao&lt;9){ miao=”0”+miao; } arr.push(miao); return arr; }}​ 轮播图双下标 window.onload=function () { let Box1=document.querySelectorAll(“div.box .box1”); //5个小盒子盒子 let box=document.querySelector(“div.box”); //大盒子 let Width=parseInt(getComputedStyle(box,null).width); //小盒子的宽度 let Left=document.querySelector(“div.box .left”); //左右两个盒子 let Right=document.querySelector(“div.box .right”); let circle=document.querySelector(“div.box .circle”); //小圆圈 let Son=document.querySelectorAll(“div.box .circle .son”);//小点 console.log(Box1,Width,Left,Right,Son); let now=0; let next=0; flag=true; let t=setInterval(move2,2000); //右向左 function move2() { next++; if(next==Box1.length){ next=0; } // 就绪 Son[next].classList.add(“son1”); Son[now].classList.remove(“son1”); Box1[next].style.left=Width+”px”; //动画 animate(Box1[next],{left:0}); animate(Box1[now],{left:-Width},function () { flag=true; }); now=next; } //左向右 function move3() { next–; if(next&lt;0){ next=Box1.length-1; } //就绪 Box1[next].style.left=-Width+”px”; Son[next].classList.add(“son1”); Son[now].classList.remove(“son1”); //动画 animate(Box1[next],{left:0}); animate(Box1[now],{left:Width},function () { flag=true; }); now=next; } box.onmouseenter=function () { clearInterval(t); } box.onmouseleave=function () { t=setInterval(move2,2000) } Left.onclick=function () { if(flag==false){ return; } if(next==0){ return; } flag=false; move3(); } Right.onclick=function () { if(flag==false){ return; } if(next==Box1.length-1){ return; } flag=false; move2(); } Son.forEach(function(value,index){ value.onclick=function(){ if(index==now){ return; } else if(index&gt;now){ Son[index].classList.add(“son1”); Son[now].classList.remove(“son1”); //就绪 Box1[now].style.left=-Width+”px”; Box1[index].style.left=0; } else if(index&lt;now){ Son[index].classList.add(“son1”); Son[now].classList.remove(“son1”); //就绪 Box1[now].style.left=Width+”px”; Box1[index].style.left=0+”px”; } now=next=index; } })}单下标 tupian下包含 a a下包含imgtupian x y 同级 let tupian = daohang.getElementsByClassName(“tupian”)[0]; let a1 = tupian.getElementsByTagName(“a”); let img = tupian.getElementsByTagName(“img”); let z = daohang.getElementsByClassName(“z”)[0]; let y = daohang.getElementsByClassName(“y”)[0]; let x = daohang.getElementsByClassName(“x”)[0]; let Son = x.getElementsByClassName(“son”); num = 0; let t = setInterval(move, 2000); function move() { num++; if (num == img.length) { num = 0; } for (let i = 0; i &lt; img.length; i++) { a1[i].style.zIndex = 20; Son[i].className = “son”; } Son[num].className = “son son1”; a1[num].style.zIndex = “30” } img.onmouseenter = function () { clearInterval(t) } img.onmouseleave = function () { t = setInterval(move, 2000) } tupian.onmouseenter = function () { clearInterval(t); }​ tupian.onmouseleave = function () { t = setInterval(move, 2000); } z.onclick = function () { a1[num].style.zIndex = 20; } y.onclick = function () { move(); } for (let i = 0; i &lt; Son.length; i++) { Son[i].onclick = function () { for (let j = 0; j &lt; Son.length; j++) { Son[j].className = “son”; } a1[i].style.zIndex = “40”; Son[i].className = “son son1”; num = i; } } function move1() { num–; if (num &lt; 0) { num = a1.length - 1; } for (let j = 0; j &lt; a1.length; j++) { a1[j].style.zIndex = 20; Son[j].className = “son” } Son[num].className = “son son1” a1[num].style.zIndex = 30; } z.onclick = function () { move1(); }透明度轮播 轮播 *{ padding:0; margin:0; list-style: none; } div.box{ height: 250px; width: 500px; margin: 0 auto; position: relative; } div.box .imgbox{ height: 100%; width: 100%; position: relative; } div.box .imgbox div{ height: 100%; width: 100%; position: absolute; top:0; left:0; opacity: 0; } div.box .imgbox .active{ opacity: 1; } div.box .next{ height: 50px; width: 15px; position: absolute; right: 0; top:50%; margin-top:-25px; background: black; opacity: 0.8; } div.box .pre{ height: 50px; width: 15px; position: absolute; left: 0; top:50%; margin-top:-25px; background: black; opacity: 0.8; } div.box ul{ height: 10px; width: 50px; position: absolute; bottom:25px; right:25px; display: flex; justify-content: space-between; align-items: center; } div.box ul li{ height: 10px; width: 10px; border-radius: 50%; background: white; } div.box ul .active{ background: #b0b0b0; } $(function(){ let num=0; let t=setInterval(move,2000); function move(type=\"next\"){ if(type==\"next\"){ num++; }else if(type==\"pre\"){ num--; } if(num>=$(\"div.box .imgbox div\").length){ num=0 } if(num","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"HTML知识点总结","slug":"HTML知识点总结","date":"2019-11-23T05:20:10.000Z","updated":"2019-11-23T05:22:39.647Z","comments":true,"path":"2019/11/23/HTML知识点总结/","link":"","permalink":"http://yoursite.com/2019/11/23/HTML知识点总结/","excerpt":"","text":"HTML 初识HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 我是斜体的字体 1 1234567可以用Ctrl+D复制上一行1 HTML标签：作用所有HTML中标签的一个根节点。2 head标签：作用：用于存放：title,meta,base,style,script,link注意在head标签中我们必须要设置的标签是title3.title标签：作用：让页面拥有一个属于自己的标题。4.body标签：作用：页面在的主体部分，用于存放所有的HTML标签：p,h,a,b,u,i,s,em,del,ins,strong,imgHTML标签分类在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 、、都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素1.双标签&lt;标签名&gt; 内容 &lt;/标签名&gt;1该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 比如 我是文字 1 2.单标签&lt;标签名 /&gt;1单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。 比如 1 HTML标签关系标签的相互关系就分为两种：1.嵌套关系 1 2.并列关系 12 文档类型 1 这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号 字符集 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。gb2312 简单中文 包括6763个汉字BIG5 繁体中文 港澳台等用GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312UTF-8则包含全世界所有国家需要用到的字符记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。不管是谁都能看懂这块内容是什么。遵循的原则：先确定语义的HTML ，再选合适的CSS。HTML标签首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。标题标签 (熟记)单词缩写： head 头部. 标题为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 、、、、和1标题标签语义： 作为标题使用，并且依据重要性递减1其基本语法格式如下： 标题文本 1 注意： h1 标签因为重要，尽量少用 单词缩写： paragraph 段落在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 文本内容 1 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签(认识) 单词缩写： horizontal 横线 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： 是单标签 1 在网页中显示默认样式的水平线。 换行标签 单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 1 这时如果还像在word中直接敲回车键换行就不起作用了。 div span标签(重点) div span 是没有语义的 是我们网页布局主要的2个盒子 div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 div的宽度是100% span宽度和高度都取决于内容的高度和宽度 span是小盒子 包裹小元素 或者是简单的文本 $美少女战士$ 默认字体 1234567891011 语法格式： 这是头部 今日价格 1 文本格式化标签(熟记) 在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈 标签属性 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： 内容 1 在上面的语法中， 1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=“value” 的格式 比如: 1 属性 是 宽度 值 是 400 图像标签img (重点) 单词缩写： image 图像 HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。其基本语法格式如下： 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 1 链接标签(重点) 单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下： 文本或图像 1 href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用 target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 < a href=“index.html”> 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=\"#\")，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位 （难点） 通过创建锚点链接，用户能够快速定位到目标内容。 创建锚点链接分为两步： 1.使用“a href=”#id名>“链接文本\"创建链接文本。 2.使用相应的id名标注跳转目标的位置。123base 标签base 可以设置整体链接的打开状态base 写到 之特殊字符标签 （理解）路径可以分为： 相对路径和绝对路径相对路径 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如。图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如。图像文件位于HTML文件的上一级文件夹：在文件名之前加入“…/” ，如果是上两级，则需要使用 “…/ …/”，以此类推，如。 绝对路径绝对路径“D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。列表标签什么是列表？ 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： 列表项1 列表项2 列表项3 ...... 123456 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 中只能嵌套，直接在标签中输入其他标签或者文字的做法是不被允许的。 与之间相当于一个容器，可以容纳所有元素。 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol （了解）有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： 列表项1 列表项2 列表项3 ...... 123456 所有特性基本与ul 一致。 但是实际工作中， 较少用 ol ，因此我们用一句话来总结下 ol： 自定义列表（理解） 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： 名词1 名词1解释1 名词1解释2 ... 名词2 名词2解释1 名词2解释2 ... 12345678910 程序如下： $美少女战士$ 11 22 33 44 55 美国 34 &lt;/li&gt; &lt;li&gt;121&lt;/li&gt; &lt;li&gt;121&lt;/li&gt; &lt;li&gt;121&lt;/li&gt; &lt;li&gt;121&lt;/li&gt; 配送方式 上门自提 上门自提 上门自提 上门自提 上门自提 123456789101112131415161718192021222324252627282930313233343536373839404142434445 表格 table(会使用) ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 创建表格 在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下： 单元格内的文字 ... ... 1234567 在上面的语法中包含三对HTML标签，分别为 、、，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释。 1.table用于定义一个表格。 2.tr 用于定义表格中的一行，必须嵌套在 table /table标签中，在 table /table中包含几对 tr /tr，就有几行表格。 3.td /td：用于定义表格中的单元格，必须嵌套在标签中，一对 中包含几对，就表示该行中有多少列（或多少个单元格）。 注意： 1. 中只能嵌套 1 2. 标签，他就像一个容器，可以容纳所有的元素 1 表格属性 边框 可以给表格以及表格中的单元格设置1像素的边框，数值变大只有table的边框变粗，单元格边框不变。 单元格间距 合并单元格rowspan 属性规定单元格可纵跨的行数。例如：该单元格占两行一列colspan 属性规定单元格可横跨的列数。例如：该单元格占一行两列 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签替代相应的单元格标签即可。表格结构（了解）在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示： ：用于定义表格的头部。 必须位于 标签中，一般包含网页的logo和导航等头部信息。 ：用于定义表格的主体。 位于标签中，一般包含网页中除头部和底部之外的其他内容。12345678910合并单元格跨行合并：rowspan 跨列合并：colspan合并单元格的思想：​ 将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。​ 公式： 删除的个数 = 合并的个数 - 1表单标签 表单控件：​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。提示信息：​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。表单域：​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。input 控件(重点)在上面的语法中，标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，标签还可以定义很多其他的属性，其常用属性如下表所示。label标签(理解)label 标签为 input 元素定义标注（标签）。作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点如何绑定元素呢？for 属性规定 label 与哪个表单元素绑定。Male12textarea控件(文本域)如果需要输入大量的信息，就需要用到标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 文本内容123下拉菜单使用select控件定义下拉菜单的基本语法格式如下 选项1 选项2 选项3 …123456注意： 中至少应包含一对。在option 中定义selected =” selected “时，当前项即为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 各种表单控件 123 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。method用于设置表单数据的提交方式，其取值为get或post。name用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。HTML5新标签与特性文档类型设定 document HTML:XHTML:HTML5 字符设定 ：HTML与XHTML中建议这样去写 ：HTML5的标签中建议这样去写 常用新标签 header：定义文档的页眉nav：定义导航链接的部分footer：定义文档或节的页脚article：标签规定独立的自包含内容section：定义文档中的节（section、区段）aside：定义其所处内容之外的内容 常用新属性 属性**用法**含义**** placeholder**** 占位符提供可描述输入字段预期值的提示信息 autofocus**** 规定当页面加载时 input 元素应该自动获得焦点 multiple**** 多文件上传 autocomplete**** 规定表单是否应该启用自动完成功能 required**** 必填项 accesskey**** 规定激活（使元素获得焦点）元素的快捷键 新增的type属性值： 类型**使用示例**含义**** email**** 输入邮箱格式 tel**** 输入手机号码格式 url**** 输入url格式 number**** 输入数字格式 search**** 搜索框（体现语义化） range**** 自由拖动滑块 time**** date**** datetime**** month**** week**** 综合案例 学生档案 姓名: 手机号码: 邮箱地址: 所属学院: 入学成绩: 基础水平: 入学日期: 毕业日期: 123456789101112131415161718192021222324252627 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体 audioHTML5通过标签来解决音频播放的问题。可以通过附加属性可以更友好控制音频的播放，如：autoplay 自动播放controls 是否显不默认播放控件loop 循环播放由于版权等原因，不同的浏览器可支持播放的格式是不一样的多媒体 videoHTML5通过标签来解决音频播放的问题。同音频播放一样，使用也相当简单同样，通过附加属性可以更友好的控制视频的播放autoplay 自动播放controls 是否显示默认播放控件loop 循环播放width 设置播放窗口宽度height 设置播放窗口的高度","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"C语言基础概念","slug":"C语言基础概念","date":"2019-11-03T03:58:30.000Z","updated":"2019-11-03T03:59:19.808Z","comments":true,"path":"2019/11/03/C语言基础概念/","link":"","permalink":"http://yoursite.com/2019/11/03/C语言基础概念/","excerpt":"","text":"C语言程序设计基础知识点1、函数是C语言的基本构成单位。main函数是C语言程序的唯一入口。2、C语言程序开发过程。编译过程：将以.c或.cpp结尾的源程序文件经过编译成计算机能识别的二进制文件目标文件，编译过程中，编译器会检查每条语句的语法错误。链接过程：连接器将所生成的目标文件链接生成最后可直接运行的的执行文件。3、算法：解决问题的具体步骤的描述。算法的特性：—有穷性：算法必须在有限步骤后结束，而且每一步都在有限时间内完成。—确定性：每条指令无二义性。相同的输入只能得到相同的输出。—可行性：算法描述中的操作和功能都可以通过已实现的基本运算执行有限次来实现。—输入：算法有零个或多个输入。—输出：算法至少有一个或多个输出。4、变量命名规则：大小写字母、数字和下划线组成，可以以字母或下划线开头，不能使C语言的关键字。5、数据类型：基本数据类型有int，char，float，double，void整形： int 占4个字节16位。-3276832767无符号整形： unsigned int 占4个字节16位。065537短整型： short int 占2个字符8位。无符号短整型：unsigned short 占2个字节8位。长整型： long int 占4个字节32位。无符号长整型：unsigned long int 占4个字字节32位。float和double类型的异同：–同：都是C语言的浮点数据类型，带精度的数据类型。–异：占用内存不同：单精度浮点型占用4个字节，双精度浮点型占用8个字节。有效数位不同：float有效数位8个，double有效数位16个。char类型：内存中以ASCII码存放，在其取值范围内可以与整数一起使用，如：char c = ‘A’ + 10；则c为K。常见的字符对应的ASCII码：’0’：48，’A’：65，’a’：97大小写字母ASCII值相差32。6、运算符算术运算符：+ - * / % ++ – (注：%两边的对象都需要是正数)赋值运算符：= += -= *= /= %=关系运算符：&gt; &lt; &gt;= &lt;= == !=逻辑运算符：&amp;&amp; || ！三元运算符：表达式1 ？表达式2 ：表达式3运算符优先级：（ ）： 自左向右结合! ++ – sizeof： 自右向左结合 / %： 自左向右结合 ： 自左向右结合&lt; &gt; &lt;= &gt;=：自左向右结合== !=： 自左向右结合&amp;&amp; ||： 自左向右结合= += -= = /= %= 自左向右结合7、类型转换自动转换：不同数据类型的数据进行运算时，由编译器自动完成。转换规则：由短整型和字符型向整形转换，整形向无符号整形转换，无符号整形向长整型转换，长整型和单精度浮点型向双精度浮点型转换。（字节少的向字节多的转换）强制类型转换：（类型名）变量名或数值。如果是高向低转换则会丢失多余的精度。低精度向高精度转换，多余的补上0。8、输入输出（1）printf函数常见格式控制字符%d：将参数按整形输出。%c：按字符输出。%s：输出字符串。%f：带小数点形式输出。%md：输出数据占m个位宽，数据长度左补空格，超出按原样输出。%m.nf：n表示小数位数。（2）putchar( )： 向终端输出一个字符。注意：使用没有换行符。（3）puts( )： 向终端输出字符串。int puts(const char *string);（4）scanf( )： 输入。int scanf(const char * restrict format,…); 注：从终端中输入空格，会使scanf获取终端，空格后面的舍弃。（5）getchar( )：向终端接受一个字符。getc(stdin)（6） gets( )：向终端接受一个字符串。char *gets(char *string);注意：gets不检测字符串string的大小，容易造成溢出，且LinuxC不支持该函数，可以使用fgets代替。fgets(s, size, stdin)。9、程序结构设计（1）程序的三种基本机构：顺序结构，分支结构，循环结构。（2）分支结构：if if-else switch-case注意1：if-else语句的二义性，C语言规定else永远与最近的if配对。合理的编程规范，if-else每一个语句块均使用{ }括出。注意2：switch括号中要求数据类型为整形或字符表达式。注意case后面要有break跳出，不然会一直往下执行，知道找到一个break跳出或者继续往下执行完default。（3）循环结构：while( ) do-while( )； for( )（4）continue：只能在循环里面试用，作用：结束该次循环，直接执行下一次循环。（5）break：结束该层循环。10、数组数组的特点：数组在内存中连续存储多个元素的结构，一个数组存放的元素的地址是连续的。数组的大小是固定的，所有的元素的数据类型是相同的。数组的定义和初试化：定义：数据类型 数组名[数组大小]；一维数组初始化：int array[10] = {10,9,8,7,6,5,4,3,2,1}；int array[10]={10,9,8,7,6,5,4,3,2,1,0};//越界数组初试化元素个数小于数组大小，后面默认为0。 二维数组初始化：int array[2][3]={ {1,2,3}, {4,5,6} };定义二维数组可以省略第一维的值，但不能省略第二维的值。二维数组的存放顺序是按行存放。如：int array[][3]={ {1,2,3}, {4,5,6} };//定义2行3列数组int array[2][]={ {1,2,3}, {4,5,6} };//错误，不能省列值。数组的使用：数组的索引是从0开始。一维数组：array[序列号]二维数组：array[行序列号][列序列号]11、字符串（1）字符串是由双引号括起来的存放在连续内存地址的任意字符。C语言中没有特定的字符串变量，通常使用数组存放字符串。字符串的定义方式：char string = “Hello”;//使用指针定义一个字符串常量char string[]=”Hello”;//使用数组定义一个字符串。（2）字符数组与字符串的区别：定义：字符数组：存储字符的数组。字符串数组：一种特殊的字符数组，存放以\\0结尾。长度：字符数组大小与字符数相同，字符串数组的大小等于字符数加上结束符’\\0’。（3）字符串处理函数：拷贝char *strcpy(char dest, const char *src)：拷贝字符串，注意该函数没有限定大小，容易越界，char *strncpy(char *dest,char *src,size_t n);拷贝字符串，对strcpy进行优化，限制了拷贝长度，注意如果长度size与dest数组大小相等时，会缺少结束符\\0。int sprintf( char *buffer, const char *format [, argument] … );建议使用sprintf函数拷贝字符串。void memcpy(void *dest, const void *src, size_t n); 内存块拷贝，需要注意的是第一第二个参数需要是指针。strcat：字符串连接。extern char *strcat(char *dest, const char *src);strcmp(str1, str2)：字符串比较。相同返回0。strlen( s1[], s2[])：字符串长度。12、指针指针也是一个变量，只不过该变量存放的是另外一个对象的内存地址。声明和初始化：指针变量类型 *指针变量名。使用指针时，需要在定义的同时进行声明，防止出现野指针。指针变量名=NULL；指针的运算：指针变量 = 地址;int a[5]; int *p = a;定义数组名为a的数组，将数组的首地址赋值给p。p指向数组的第一个元素。&amp;a[0]表示数组的第一个元素的地址。数组第1个元素的地址： a，&amp;a[0]，p数组第i+1个元素的地址：a+i, &amp;a[i], p+i, &amp;p[i]数组的第一个元素的值： a[0], p[0], *a, *p数组的第i+1个元素的值： a[i], p[i], *(a+i), *(p+i) – ：使用一次递增递减，指针就移动一个单位，一个类型为T的指针的移动。指针加上或减去某个整数值n：指针将移动n个单位。13、typedef ：typedef 类型名 标识符typedef只是将已经存在的类型用一个新的名字来代表。typedef可以为各种类型说明一个新名，但不能用来为变量名说明一个新名。14、枚举：enum 枚举名 {符号1，符号2…}枚举类型为一组在逻辑上密不可分的整形提供便于记忆的符号。默认情况下第一个枚举符号值为0，往后一个加1。15、结构结构是一种构造数据类型，它是由若干数据项组合而成的复杂的数据对象，这些数据项称为结构成员。定义结构：struct structrename{datatype variable1；datatype variable2；…};声明结构变量：struct 结构名 结构变量名；表示结构变量成员：变量名.成员名;16、预处理命令宏定义：#define 标识符 字符串：在编译时，将用字符串替换程序中出现的所有标识符。如：#define PI 3.14文件包含处理：#include“文件名”：系统将先在用户当前目录下查找文件，找不到将在系统目录下找。#include&lt;文件名&gt;：&lt;&gt;系统只在系统目录中查找该文件。","categories":[],"tags":[]},{"title":"JAVA基础知识","slug":"JAVA基础知识","date":"2019-11-03T02:39:49.000Z","updated":"2019-11-03T02:41:16.970Z","comments":true,"path":"2019/11/03/JAVA基础知识/","link":"","permalink":"http://yoursite.com/2019/11/03/JAVA基础知识/","excerpt":"","text":"java基础知识概述：1991 年Sun公司的James Gosling（詹姆斯·高斯林）等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器； 1994年将Oak语言更名为Java； Java的三种技术架构: JAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发； JAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础； JAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序； 1，JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。 2，JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。 3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。 环境变量的配置：1）：永久配置方式：JAVA_HOME=%安装路径%\\Java\\jdk path=%JAVA_HOME%\\bin 2）：临时配置方式：set path=%path%;C:\\Program Files\\Java\\jdk\\bin 特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。 classpath的配置:1）：永久配置方式：classpath=.;c:;e:2）：临时配置方式：set classpath=.;c:;e:\\ 注意：在定义classpath环境变量时，需要注意的情况 如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件； 如果指定了classpath，那么会在指定的目录下查找要运行的类文件。 还会在当前目录找吗？两种情况： 1）：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。 2）：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。 一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。 4，javac命令和java命令做什么事情呢？ 要知道java是分两部分的：一个是编译，一个是运行。javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。java：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数. java语法基础：1，关键字：其实就是某种语言赋予了特殊含义的单词。保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。 2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；注意： 1），数字不可以开头。 2），不可以使用关键字。 3，常量：是在程序中的不会变化的数据。 4，变量：其实就是内存中的一个存储空间，用于存储常量数据。 作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。 特点：变量空间可以重复使用。 什么时候定义变量？只要是数据不确定的时候，就定义变量。 变量空间的开辟需要什么要素呢？ 1，这个空间要存储什么数据？数据类型。 2，这个空间叫什么名字啊？变量名称。 3，这个空间的第一次的数据是什么？ 变量的初始化值。 变量的作用域和生存期: 变量的作用域： 作用域从变量定义的位置开始，到该变量所在的那对大括号结束； 生命周期： 变量从定义的位置开始就在内存中活了； 变量到达它所在的作用域的时候就在内存中消失了； 数据类型：1）：基本数据类型：byte、short、int、long、float、double、char、boolean2）：引用数据类型: 数组、类、接口。 级别从低到高为：byte,char,short(这三个平级)–&gt;int–&gt;float–&gt;long–&gt;double 自动类型转换：从低级别到高级别，系统自动转的； 强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量； 运算符号：1）、算术运算符。 + - * / % %:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。 +:连接符。 ++,– 2）、赋值运算符。 = += -= *= /= %= 3）、比较运算符。 特点：该运算符的特点是：运算完的结果，要么是true，要么是false。 4）、逻辑运算符。 &amp; | ^ ! &amp;&amp; || 逻辑运算符除了 ! 外都是用于连接两个boolean类型表达式。 &amp;: 只有两边都为true结果是true。否则就是false。 |:只要两边都为false结果是false，否则就是true ^:异或：和或有点不一样。 两边结果一样，就为false。 两边结果不一样，就为true. &amp; 和 &amp;&amp;区别： &amp; ：无论左边结果是什么，右边都参与运算。 &amp;&amp;：短路与，如果左边为false，那么右边不参数与运算。 | 和|| 区别：|：两边都运算。 ||：短路或，如果左边为true，那么右边不参与运算。5）、位运算符:用于操作二进制位的运算符。 &amp; | ^ &amp; &lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移)练习：对两个变量的数据进行互换。不需要第三方变量。 int a = 3,b = 5;--&gt;b = 3,a = 5; a = a + b; a = 8; b = a - b; b = 3; a = a - b; a = 5; a = a ^ b;// b = a ^ b;//b = a ^ b ^ b = a a = a ^ b;//a = a ^ b ^ a = b; 练习：高效的算出 2*8 = 2&lt;&lt;3;5，语句。 If switch do while while for 这些语句什么时候用？ 1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。 但是建议使用switch，效率相对较高。 switch(变量){ case 值:要执行的语句;break; … default:要执行的语句; } 工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了 就执行哪个case后面的语句，如果没有相同的则执行default后面的语句； 细节：a：break是可以省略的，如果省略了就一直执行到遇到break为止； b：switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种； c：default可以写在switch结构中的任意位置；如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。 2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。 3）、当某些语句需要执行很多次时，就用循环结构。 while和for可以进行互换。区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。 break:作用于switch ，和循环语句，用于跳出，或者称为结束。 break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。 continue:只作用于循环结构，继续循环用的。 作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。 6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。 java中的函数的定义格式： 修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){ 执行语句； return 返回值； }没有具体的返回值时，返回的返回值类型用void关键字表示。 如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。 return的作用：结束函数。结束功能。 如何定义一个函数？ 函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成： 1）、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。 2）、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&amp;参数个数)。 函数的作用： 1）、用于定义功能。 2）、用于封装代码提高代码的复用性。 注意：函数中只能调用函数，不能定义函数。 主函数： 1）、保证该类的独立运行。 2）、因为它是程序的入口。 3）、因为它在被jvm调用。 函数定义名称是为什么呢？ 答：1）、为了对该功能进行标示，方便于调用。 2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。 重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。 如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。 7，数 组：用于存储同一类型数据的一个容器。好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。 如何在java中表现一个数组呢？两种表现形式。 1）、元素类型[] 变量名 = new 元素类型[元素的个数]； 2）、元素类型[] 变量名 = {元素1，元素2…}； 元素类型[] 变量名 = new 元素类型[]{元素1，元素2…}； //二分查找法。必须有前提：数组中的元素要有序。 public static int halfSeach_2(int[] arr,int key){ int min,max,mid; min = 0; max = arr.length-1; mid = (max+min)&gt;&gt;1; //(max+min)/2; while(arr[mid]!=key){ if(key&gt;arr[mid]){ min = mid + 1; } else if(key&lt;arr[mid]) max = mid - 1; if(max&lt;min) return -1; mid = (max+min)&gt;&gt;1; } return mid; } java分了5片内存。 1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。 栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )； 只要数据运算完成所在的区域结束，该数据就会被释放。 堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。 1：每一个实体都有内存首地址值。 2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。 3：垃圾回收机制。","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"pycharm安装步骤","slug":"pycharm安装步骤","date":"2019-11-03T02:15:31.000Z","updated":"2019-11-03T02:24:57.115Z","comments":true,"path":"2019/11/03/pycharm安装步骤/","link":"","permalink":"http://yoursite.com/2019/11/03/pycharm安装步骤/","excerpt":"","text":"1、首先去Pycharm官网，或者直接输入网址：http://www.jetbrains.com/pycharm/download/#section=windows，下载PyCharm安装包，根据自己电脑的操作系统进行选择，对于windows系统选择下图的框框所包含的安装包。Python环境搭建—安利Python小白的Python和Pycharm安装详细教程 2、选择Windows系统的专业版，将其下载到本地，如下图所示： 3、双击下载的安装包，进行安装，然后会弹出界面： 4、选择安装目录，Pycharm需要的内存较多，建议将其安装在D盘或者E盘，不建议放在系统盘C盘： 5、点击Next，进入下图的界面： Create Desktop Shortcut创建桌面快捷方式，一个32位，一个64位，小编的电脑是64位系统，所以选择64位。 勾选Create Associations是否关联文件，选择以后打开.py文件就会用PyCharm打开。 6、点击Next，进入下图： 默认安装即可，直接点击Install。 7、耐心的等待两分钟左右，如下图： 8、之后就会得到下面的安装完成的界面： 9、点击Finish，Pycharm安装完成。接下来对Pycharm进行配置，双击运行桌面上的Pycharm图标，进入下图界面： 选择Do not import settings，之后选择OK，进入下一步。 10、选择Accept，进入下一步： 11、进入激活界面，选择第二个License server，如下图所示： 之后在License server address中随意输入下面两个注册码中的任意一个即可，Pycharm新注册码1：http://idea.liyang.io或pycharm新注册码2：http://xidea.online，之后点击OK，便可以激活Pycharm了。 12、Pycharm激活后 END","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"win10系统Tomcat环境变量配置步骤","slug":"win10系统Tomcat环境变量配置步骤","date":"2019-11-03T01:58:55.000Z","updated":"2019-11-03T02:02:01.439Z","comments":true,"path":"2019/11/03/win10系统Tomcat环境变量配置步骤/","link":"","permalink":"http://yoursite.com/2019/11/03/win10系统Tomcat环境变量配置步骤/","excerpt":"","text":"一、环境的搭建 1、下载JAVA JDK，选择所要安装的目录安装。官网下载地址：http://java.sun.com/javase/downloads/index.jsp 2、设置环境变量。 在CLASSPATH环境变量后加上（即加上jdk安装路径下的tools.jar和dt.jar文件）： .;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar;path和JAVA_HOME的配置省略（Java初学者必备常识，不会百度“JDK的安装”）。接着下载解压Apache的Tomcat7.0.6，并将其放在自己想要的位置上。 随后在CLASSPATH环境变量中配置Tomcat（即加上Tomcat的lib库中的jsp-api.jar和servlet-api.jar文件） 1E:\\Tomcat\\lib\\jsp-api.jar;E:\\Tomcat\\lib\\servlet-api.jar;4. 在配置好环境后，在Tomcat的bin目录下找到startup.bat文件并双击打开，如果配置成功应该可以看见黑盒子里写的启动信息而不是闪退： 之后打开浏览器输入http://localhost:8080（注意startup.bat文件要一直开着），回车就看到服务器的信息了： 6.如果不能打开可能是端口冲突，需要修改端口。方法是打开Tomcat的conf目录下的server.xml文件，注意用记事本或notepad++等打开，将以下语句的port值8080改为自定义的端口号:","categories":[],"tags":[{"name":"writer:QS","slug":"writer-QS","permalink":"http://yoursite.com/tags/writer-QS/"}]},{"title":"2019-10-31JDK的创建步骤","slug":"JDK的创建步骤","date":"2019-10-31T10:25:16.000Z","updated":"2019-10-31T10:31:19.916Z","comments":true,"path":"2019/10/31/JDK的创建步骤/","link":"","permalink":"http://yoursite.com/2019/10/31/JDK的创建步骤/","excerpt":"","text":"JDK的创建步骤1打开浏览器，输入JDK搜索，根据搜索结果下载安装包安装应用 2先接受协议，再根据自己的电脑下载相应的JDK版本，默认安装就行了。 3配置环境变量。找到安装路径，默认安装的一般都是在这个路径下C:\\Program Files\\Java\\jdk1.8.0_77 4然后点击电脑开机键，打开控制面板 5然后点击系统安全，打开进入 6点击系统 7点击“高级系统设置” 8点击高级中的“环境变量” 9在下面的系统变量中点击“新建” 10新建JAVA_HOME、CLASSPATH这两个项，最后在path中添加上去就完成了 11新建CLASSPATH，变量值 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar，注意前面有个点的 12将这两个变量加到path里面，直接在后面添加 ;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin，注意前面要有个分号“;” 13变量操作界面点击确定关闭 14系统高级设置页面点击“确定”关闭 15两个变量配置好了，到时直接可以在控制台编译运行Java文件，运行cmd查看Java环境是否配好。 16输入javac，按回车键，出现下面这些说明编译环境配好了 17再输入java，按回车键，出现下面这些，说明运行环境也好了。 END","categories":[],"tags":[]},{"title":"python知识点总结","slug":"python知识点总结","date":"2019-10-31T09:46:49.000Z","updated":"2019-10-31T09:48:18.950Z","comments":true,"path":"2019/10/31/python知识点总结/","link":"","permalink":"http://yoursite.com/2019/10/31/python知识点总结/","excerpt":"","text":"1、Python的两种编程方式：交互式（随输随运行）和文件式（主要方式；批量运行出结果） 2、一切皆对象，每个对象由标识（id()）、类型（type()）和值（print()）标识。 3、Python采用基于值的内存管理,不同变量赋值为同一个值，ID一样，但是只适用范围在-5至256的整数和短字符串。 4、内置函数（BIF），68个，查看方式：dir(builtins)分类：数值数据类型：int,float,complex,bool,decimal,fractions序列数据类型：字符串（string）、列表（list）、元祖（tuple）、bytes、bytearray集合数据类型：set、frozenset字典数据类型：dict不可变的数据类型：数值Number、字符串String、元祖Tuple可变的数据类型：列表List、字典Dict、集合Set 5、二进制：0b/0B开头八进制：0o/0O开头十六进制;0x/0X开头 6、数值运算函数：abs(x)：绝对值 ；divmod(x,y)：商余 ；pow(x,y,z)：幂余（(x**y)%z） ；round(x,d)：四舍五入d位 ；max/min ； int(x) /float(x) /complex(x) 7、math库：常数：math.pi ；math.fabs(x)：绝对值 ；math.fmod(x,y)：x%y ；math.ceil(x)：向上取整，返回不小于x的最小整数 ；math.floor(x)：向下取整，返回不大于x的最大整数 ；math.modf(x)：返回x的小数和整数部分 ；math.trunc(x)：返回x的整数部分 8、浮点数类型：0.1 + 0.2不等于 0.3 ，浮点数有小尾数。看是否等于可以用round（）函数帮助去小尾数。 9、类型间混合运算：整数 -&gt; 浮点数 -&gt; 复数 10、布尔数据类型（bool）包含两个值-&gt;True（真–1）或假（False–0）。如果表达式的结果为数值类型的0、空字符串（“”）、空元祖（）、空列表[]、空字典{}，则其布尔值为false（假），否则为true（真）。 11、逻辑运算符：and、or、nota and b等于a if not a else b ； a or b 等于a if a else b。not一定会返回true或false；and和or不一定。 12、运算优先级（由高到低）**（指数）&gt; +x.-x（正负号）&gt; *./.%（乘。除。取余）&gt; +. -（加。减）&gt; &amp;(与）&gt; ^（或）&gt; \\（非）&gt;比较大小&gt; not（非）&gt; and（与）&gt;or（或）&gt; lambda表达式 13、序列型数据（1）序列的索引s[i]：如果索引下标越界，导致IndexError；如果索引下标不是整数，导致TypeError。（2）序列的切片（截取序列s的一部分）：顾头不顾尾。（3）序列的加：x + y：连接两个序列； 序列的乘（复制）：x * n：复制n次序列x ；（4）判断子串：x in s ：返回True/False ； s.count(x)：返回x在s中出现的次数 ； s.index(x,i,j)：返回x在s（范围[i,j]）中第一次出现的索引位置。（5）序列的排序：sorted(s, key=None,reverse=False)。reverse为false是为升序，为true时为倒序。返回结果为一个列表。（6）序列的拆封赋值：当变量个数和序列长度相等时，一一对应赋值。如a,b = (1,2)即a = 1,b = 2。不等则导致ValueError。或使用变量（将多个值作为整体赋给变量）或使用临时变量‘_’ 14、字符串类型 比较字符ASCII码值的大小：空格&lt;数字&lt;大写字母&lt;小写字母Unicode变字符：chr(u) ；字符变Unicode：ord(x)format（）方法的格式控制：（1）槽{序号}的使用（2）{参数序号：格式控制标记}，格式控制标记包括：填充、对齐（分别用&lt;、&gt;、^表示左、右和居中对齐）、宽度、精度、类型（b=二进制，c=Unicode,d=十进制，o=八进制，xX=十六进制）。（3）字符串的类型判断：str.isdigit()是否全为数字（0-9）；str.isalpha()是否全为字母；str.isal num()是否全为数字或字母；str.isspace()是否是空白（空格、制表符、换行符等）；str.isprintable()是否可打印（空格和没有东西是可以被打印的）；str.isidentifier()是否满足标识符定义规则（字母或下划线开头，只含数字、字母和下划线）（4）大小写转换：str.capitaiize()：转换为首字母大写，其余小写；str.title()各单词首字母大写。（5）对齐：居中str.center(长度，填充物) ；左对齐：ljust ；右对齐：rjust。填充：str.zfill(长度)相当于右对齐，前方补0。如果str前有正负号，则正负号也算长度，在正负号之后填充。移除：左右两边：str.strip(字符chars) ； 左边：str.lstrip() ；右边;rstrip（）（6）字符串的查找：find和indexstr.find(s):从左至右查找str中是否含s,有则返回第一次出现s的索引位置，否则返回-1str.index（x）：从左至右查找是否含有x，有则返回第一次出现的索引位置，没有则抛出ValueErrorstr.rfind()和str.rindex()就是从右至左查找。（7）字符串的替换：S.replace(old,new,count)。将S中的old替换为new，如果给定count，则只替换前count个old子串。（8）拆分/分割：S.split(分隔符sep,分割次数maxsplit), maxsplit = -1或不指定时，会从左向右搜索完整个字符串。S.rsplit()是从右往左。生成列表。S.partition(sep)，S.rpartition(sep)(从右往左搜索)。搜索S中的子串sep，并从第一个sep处分割，返回一个包含三个元素的元组 –&gt;（sep左边的部分，sep，sep右边的部分）。如果搜索不到sep，则返回中有两个元素为空，partition是后两个元素为空，rpartition是前两个为空。（9）连接组合：S.join（字符串对象）。 当对象为字符串字典时，结果是键的连接。 15、列表类型 列表list是可变对象，则对其增删改查不会改变其的id。除了list.copy().方法：（1）添加：list.appand(x)：将元素x添加到列表的尾部；list.extend(L)：将列表L中所有元素添加到列表的尾部；list.insert(index,x)：在列表指定位置index处添加元素x；（2）删除：list.remove(x)：删除列表中首次出现的元素x；list.pop(kediedai[index])：删除并返回指定位置的元素（可以理解为挖取出），list为空就抛IndexError异常；list.clear()：删除列表中所有元素，但保留列表对象。（3）排序：list.reverse()：倒序；list.sort()：排序（正或倒）；（4）其他：list.index(x)：返回值为x首次出现的下标；list.count(x)：返回x的出现总次数；list.copy() ：返回列表对象的浅拷贝。很厉害！！它可以改变列表的ID！浅拷贝——只拷贝一层。如果拷贝对象只有一层，那么同b = a[:]，两个变量相互独立的。但如果拷贝对象只有一层，就会有影响，会跟着改变。（详见例题）！！列表推导式：[新元素表达式 for 临时变量 in 可迭代对象 if 条件表达式] 16、集合类型集合中的元素没有顺序，且不重复。集合set是可变的，用大括号表示。但是{}表示空字典；set()表示空集合，用set（）创建集合时，会将元素一个一个拆开，如’hello’变成’h’,‘e’,‘l’,‘l’,‘o’。集合中元素要是固定数据类型：整数、浮点数、字符串、元组等。不可为可变的列表、字典、集合。利用集合过滤掉重复的元素。4种基本操作：交（&amp;）、并（|）、差（-）、补（^）S.add() ;S.clear() ;S.copy() ; S.remove() ;len(S) ;x (not)in S ;**S.pop()：随机返回S中的一个元素，如果S为空，产生KeyError.(区分list.pop([index]))特有的：S.discard(X)；如果x在S中，移除x，不在，不报错。主要三大用途：成员关系测试、元素去重、删除数据项。 17、字典类型（映射）{建（key）：值（value）}。键不能重复，且是不可变对象。值可变。元素没有顺序。创建一个空字典：dict（） ；创建字典：dict(‘a’=1,‘b’=2)/dict(‘a’:1,‘b’:2)/dict((‘a’,1),(‘b’,2))查找值：Dict[key] ；修改键值：dict[key] = new_value ；增添新键值：dict[new_key] = new_value .D.keys()：返回所有键的列表,如dict_keys([‘a’, ‘b’, ‘c’])；D.values()：返回所有值的列表,如dict_values([1, 2, 3])；D.items()：返回所有的键值对的列表,如dict_items([(‘a’, 1), (‘b’, 2), (‘c’, 3)])；D.get(key,v)：键存在则返回相应值，否则返回None（自定义了v时，返回v的内容）;D.pop(key.value)：键存在则返回相应值，同时删除键值对，否则返回None；D.popitem()：随机取出一个键值对，以元组（key，value）形式返回；D.setdefault(k,v)：如果键k存在，返回对应值，否则添加项目k = v,v默认为None；D.update(dict)：更新或添加键值对；D.clear()：删除所有的键值对；del.D[key]：删除key对应的键值对。如果key不存在，则抛出KeyError。 遍历：for 变量名 in 字典名： 18、可变与不可变（关于值）可变：列表（有序）、集合（无序）、字典（无序）不可变：字符串（有序）、元组（有序）Python是基于值的内存管理方式，举例：a=[1,2,3],b=[1,2,3]，a==b成立。 但是id(a)与id(b)不相等，id(a[0])==id(b[0])成立。总结就是关乎值的就相等什么叫可变？即值是可变的，但id是固定不变的。例如可变的列表，修改列表L中的一个元素的值，列表L的id是不变的。不管是可变还是不可变的序列类型：（1）分片必定产生新的序列；（2）“+”号在等号右边（L=L+[i]），必定产生新的序列。然后将新的序列地址赋予给等号左边的变量。（每一次执行时都会将原列表复制一次，L指向新列表，并在新列表中加入新元素）对三种列表添加方法进行总结：（1）L=L+[i]在每一次执行时都会将原列表复制一次，L指向新列表，并在新列表中加入新元素。（2）L.append(i)只是将新元素直接添加到原列表中，不会产生新列表。（3）L+=[i]的执行效果和L.append(i)类似，也是在原列表中直接添加元素，不会复制原列表。b = a VS b = a[:]b = a时，b就是跟着a变化，并且a与b的id一样。b = a[:]时，b与a是独立的整体，id就不同，只不过指向了同一个值。对a做修改（增删改查），对b没有影响。 19、程序的三种基本结构：顺序结构、·分支结构（if-else、elif）、·循环结构（遍历：for…in、条件：while。循环控制：break/continue）。异常值处理：try-except。二分支结构简单语法：表达式1 if 条件 else 表达式2循环结构分遍历循环（for）和无限循环（while）：遍历循环：for 循环变量 in 遍历结构：语句块（从遍历结构逐一提取元素，放在循环变量中，对每一个提取出的元素执行一次语句块。）无限循环：while 条件：语句块。判断条件为True就一直循环，为false时魂环结束，执行与while同级别缩进的后续语句。break用于结束当前循环，如果有两层循环，break用于跳出最内层for或while循环，脱离该循环后程序从循环后代码继续执行；continue用来结束当前循环的当次循环过程，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。当有输入要求时，可运用异常值处理try：except： 20、函数（1）形参与实参：定义函数时的参数是形参，调用函数时的参数是实参。（2）参数传递的方法：位置参数、默认值参数、关键字参数、命名关键字参数。。。位置参数：按位置顺序传递参数值，位置参数要在所有参数之前，是第一个参数；关键字参数：关键字参数就是在调用函数，传入实参时指定形参的变量名。关键字不用遵守位置的对应关系。参数之间的顺序可以任意调整。关键字传递可以和位置传递混用。但位置参数要在关键字参数之前。举例：def hello(name,age = 11,gender = ‘F’):（age = 11,gender = ‘F’就是关键字参数）。举例：def hello(name,age = 11,gender = ‘F’):（age = 11,gender = ‘F’就是关键字参数）默认值参数：定义参数时已经给定值，一般参数为不可变对象，（如果为可变的空列表，可用于装位置参数）；可变数量参数：args、kw带有星号的可变参数只能出现在参数列表的后面。调用时，参数被当作元组类型传递到函数中。(如： def func(*args): -&gt; func(10,20))带双星号（）的参数，在使用时必须指定参数值，使用key=value这种形式，只能出现在参数列表的最后。调用时，kw后的那些参数被当作字典类型传递到函数中。（如：def func(kw): -&gt; func(a=10,b=20)）强制命名参数：参数带星号或者就是一个星号（def f(*c或,a,b,c)），强制命令参数c 的含义是它后面的参数必须用实名调用，即必须用 a = … , b = … 来调用，不能只写值。Python中只有函数，函数是有返回值的，*如果没有return，默认返回None。**return返回多个值时，多个值以元组形式保存。 21、比较（1）list.sort（）与全局sorted（）list.sort(key = None,reverse = False)是列表内置排序方法。但其返回值为None（x.sort()的结果、print（x.sort()）、x = x.sort()后x的结果都是None）,只有当文字说“执行语句x.sort（），x的值为”，x.sort（）作用的结果，需要通过打印被作用的列表才可以查看结果。true是倒序，false是正序。sorted（）：Python内置方法。返回新的列表。（2）list.reverse（）和reversed（）list.reverse()返回的是None，其作用的结果，需要通过打印被作用的列表才可以查看结果。reversed()：内置方法。经过reversed（）作用之后，返回的是一个吧序列值经过倒序的迭代器，所以，需要通过遍历或list、tuple或next（）方法，才能获得作用后的值。（3）字符串的查找：find和indexstr.find(s):从左至右查找str中是否含s,有则返回第一次出现s的索引位置，否则返回-1str.index（x）：从左至右查找是否含有x，有则返回第一次出现的索引位置，没有则抛出ValueErrorstr.rfind()和str.rindex()就是从右至左查找。 22、函数变量的作用域（1）局部变量、全局变量、globalglobal：用于在函数中直接修改全局变量的值。（2）内嵌函数内嵌函数的作用域仅限其所在的函数体内。如果要在内部函数中修改外部函数中的局部变量的值，使用nonlocal关键字。 END","categories":[],"tags":[]},{"title":"JAVA汉诺塔问题","slug":"JAVA汉诺塔问题","date":"2019-10-31T03:49:56.000Z","updated":"2019-10-31T03:51:52.768Z","comments":true,"path":"2019/10/31/JAVA汉诺塔问题/","link":"","permalink":"http://yoursite.com/2019/10/31/JAVA汉诺塔问题/","excerpt":"","text":"汉诺塔问题：有三根柱子A,B,C，其中A上面有n个圆盘，从上至下圆盘逐渐增大，每次只能移动一个圆盘，并且规定大的圆盘不能叠放在小的圆盘上面，现在想要把A上面的n个圆盘全部都移动到C上面，输出移动的总步数以及移动的过程分析：//先求出移动的总步数1，假设g（n）表示n个圆盘时的移动总的步数，当n=1时，g(1)=1;2.现在可以把g(n)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B上面，相当于将n-1个圆盘从A移动到C，因此需要g(n-1)步； 2&gt;然后将剩下的最大的圆盘从A移动到C，需要1步； 3&gt;最后再将n-1个圆盘从B通过A移动到C上面，相当于将n-1个圆盘从A移动到C，因此也需要g(n-1)步； 因此可以得出递归关系式：g(n) = 2*g(n-1)+1;//现在我们在来求出移动的过程1.假设hm(m,a,b,c)表示将m个圆盘从a通过b移动到c的过程，假设mv(a,c)输出一次a到c的过程，即print a–&gt;c2.初始化hm，当m=1时，hm(1,a,b,c)=mv(a,c);3.可以把hm(m,a,b,c)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B，此时b和c进行互换，也就是 hm(m-1,a,c,b); 2&gt;然后将剩下的最大的圆盘从A移动到C，也就是hm(1,a,b,c); 3&gt;最后将n-1个圆盘从B通过A移动到C，此时b和a进行交换，也就是 hm(m-1,b,a,c); 最终得到过程的递归关系式：hm(m,a,b,c) = hm(m-1,a,c,b)+1+hm(m-1,b,a,c); 代码：public class test{public static void main(String[] args){ Scanner in = new Scanner(System.in); int n = in.nextInt(); test t = new test(); //获取总的步数 System.out.println(“需要移动的总步数为:” +t.getSum(n)); //获取移动的过程 t.hm(n,’a’,’b’,’c’); } //获取总步数 public int getSum(int n){ if(n == 1) return 1; return 2 * getSum(n-1) +1 ; } //获取移动的过程 public void hm(int m,char a,char b,char c){ if(m == 1) move(a,c); hm(m-1,a,c,b); move(a,c); hm(m-1,b,a,c); } //输出一次移动的过程 public void move(char a,char c){ System.out.print(a + “–&gt;” + c + “ “); } }","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2019-10-13T10:01:23.000Z","updated":"2019-10-13T10:02:53.057Z","comments":true,"path":"2019/10/13/第一篇博客/","link":"","permalink":"http://yoursite.com/2019/10/13/第一篇博客/","excerpt":"","text":"Javaoop总结1.类与对象 抽象的，泛指的，是指从某一类具有相同属性和方法的对象中抽取出来 class代表类 类的作用；实例化对象，方法，工具类 类中分两大块：属性（成员变量） 方法（成员方法） 类如何实例化对象？ new Person p = new Person(); p.name = “张三”; p.sex = “男”; p：对象名 Person p1 = new Person();2. 属性与方法 方法的调用：对象名.方法名 匿名对象调用方法：new 类().方法名 new Person().getA(); int c = new Person().getD(10, 20); //实参 System.out.println(c);3.static static 静态，static用来修饰属性、方法 用static修饰属性：共有的属性——实例化出来的对象，用static修饰的具有相同的值。 用static修饰方法：能通过类名直接调用 4.封装, oopd三大特征之一； 属性私有化，公开setter和getter方法； 单例模式 只能实例化一次； 实现单例式的三个步骤：第一：私有化构造方法 private 类名（）{ } 第二：公开一个代理方法 private static 类名 方法名（）{ 类名 d=null； if（count&lt;1）{ d=new 类名（）； count++; } return d; } 第三：私有化一个静态属性，用来统计new的个数 private static int count=0; 5.继承,oop三大特征之一 继承 会让两个类产生一种关系 父类-子类 父类：从子类中抽取出共同的属性和共同的方法，放到父类中， 然后让子类继承父类，那子类就具有父类的属性和方法 继承的关键词：extends 类的继承格式 class 父类 { } class 子类 extends 父类 { } (1)父类中私有的属性和方法，子类是不能继承的 (2)父类的构造方法，子类是不能继承的 (3)父类是跨包的，除public以外的都不能被继承super 子类用来访问父类的方法或者属性 super.方法 super.属性 super()只能放在子类的构造方法中，并且只能放在第一行 重写 子类重写父类的方法； 方法名 +快捷键 多态,oop三大特征之一 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性多态存在的三个必要条件继承重写父类引用指向子类对象向上转型子类向父类的转换&lt;父类型&gt; &lt;引用变量名&gt;=new&lt;子类型&gt;;向下转型父类型转换为子类型&lt;子类型&gt;&lt;引用变量名&gt;=(&lt;子类型&gt;）&lt;父类型的引用变量&gt;; 抽象 (1)抽象 abstract abstract能修饰什么？类，方法(2) 用abstract修饰类叫抽象类 特点：抽象类不能被实例化，但能被继承 (3)用abstract修饰的方法叫抽象方法 特点：1.抽象方法没有方法体 2.抽象方法必须放在抽象类中，抽象类中的方法不一定是抽象方法 3.抽象类被子类继承后，那么子类要重写父类中的抽象方法，除非子类也是抽象类 访问权限private (私有的) 默认 (友好的) protected (受保护的) public (公共的) 9.final (1)final修饰类中的属性或者变量 无论属性是基本类型还是引用类型，final所起的作用都是变量里面存放的“值”不能变。 (2)final修饰类中的方法 作用：可以被继承，但继承后不能被重写。 (3)final修饰类 作用：类不可以被继承。 10.接口（重点） 创建接口类 public interface 接口的声明语法格式 interface 接口名称 extends 其他的接口名 { // 声明变量 // 抽象方法 } 接口关键字： interface 类要实现接口：implements class 类名 extends 父类名 implements 接口，接口，…{ //类成员 } 接口中的方法全是抽象方法 接口中的方法全部要公开public 接口不能被实例化 接口可以被多实现 接口中的属性全部是静态常量","categories":[],"tags":[]},{"title":"Readers are welcome to browse","slug":"Readers-are-welcome-to-browse","date":"2019-10-10T10:19:43.000Z","updated":"2019-10-10T10:20:41.888Z","comments":true,"path":"2019/10/10/Readers-are-welcome-to-browse/","link":"","permalink":"http://yoursite.com/2019/10/10/Readers-are-welcome-to-browse/","excerpt":"","text":"public class HelloWorld { /* 第一个Java程序 * 它将打印字符串 Hello World */ public static void main(String []args) { System.out.println(“Hello World”); // 打印 Hello World }}","categories":[],"tags":[]},{"title":"post title with whitespace","slug":"post-title-with-whitespace","date":"2019-10-10T07:03:54.000Z","updated":"2019-10-10T09:56:19.604Z","comments":true,"path":"2019/10/10/post-title-with-whitespace/","link":"","permalink":"http://yoursite.com/2019/10/10/post-title-with-whitespace/","excerpt":"","text":"python","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-09T13:21:42.052Z","updated":"2019-10-09T13:21:42.052Z","comments":true,"path":"2019/10/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}