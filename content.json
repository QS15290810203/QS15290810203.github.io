{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JDK安装步骤","slug":"JDK安装步骤","date":"2019-10-31T09:28:20.000Z","updated":"2019-10-31T09:36:54.436Z","comments":true,"path":"2019/10/31/JDK安装步骤/","link":"","permalink":"http://yoursite.com/2019/10/31/JDK安装步骤/","excerpt":"","text":"1打开浏览器，输入JDK搜索，根据搜索结果下载安装包安装应用 2先接受协议，再根据自己的电脑下载相应的JDK版本，默认安装就行了。 3配置环境变量。找到安装路径，默认安装的一般都是在这个路径下C:\\Program Files\\Java\\jdk1.8.0_77 4然后点击电脑开机键，打开控制面板 5然后点击系统安全，打开进入 6点击系统 7点击“高级系统设置” 8点击高级中的“环境变量” 9在下面的系统变量中点击“新建” 10新建JAVA_HOME、CLASSPATH这两个项，最后在path中添加上去就完成了 11新建CLASSPATH，变量值 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar，注意前面有个点的 12将这两个变量加到path里面，直接在后面添加 ;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin，注意前面要有个分号“;” 13变量操作界面点击确定关闭 14系统高级设置页面点击“确定”关闭 15两个变量配置好了，到时直接可以在控制台编译运行Java文件，运行cmd查看Java环境是否配好。 16输入javac，按回车键，出现下面这些说明编译环境配好了 17再输入java，按回车键，出现下面这些，说明运行环境也好了。 END","categories":[],"tags":[]},{"title":"JAVA汉诺塔问题","slug":"JAVA汉诺塔问题","date":"2019-10-31T03:49:56.000Z","updated":"2019-10-31T03:51:52.768Z","comments":true,"path":"2019/10/31/JAVA汉诺塔问题/","link":"","permalink":"http://yoursite.com/2019/10/31/JAVA汉诺塔问题/","excerpt":"","text":"汉诺塔问题：有三根柱子A,B,C，其中A上面有n个圆盘，从上至下圆盘逐渐增大，每次只能移动一个圆盘，并且规定大的圆盘不能叠放在小的圆盘上面，现在想要把A上面的n个圆盘全部都移动到C上面，输出移动的总步数以及移动的过程分析：//先求出移动的总步数1，假设g（n）表示n个圆盘时的移动总的步数，当n=1时，g(1)=1;2.现在可以把g(n)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B上面，相当于将n-1个圆盘从A移动到C，因此需要g(n-1)步； 2&gt;然后将剩下的最大的圆盘从A移动到C，需要1步； 3&gt;最后再将n-1个圆盘从B通过A移动到C上面，相当于将n-1个圆盘从A移动到C，因此也需要g(n-1)步； 因此可以得出递归关系式：g(n) = 2*g(n-1)+1;//现在我们在来求出移动的过程1.假设hm(m,a,b,c)表示将m个圆盘从a通过b移动到c的过程，假设mv(a,c)输出一次a到c的过程，即print a–&gt;c2.初始化hm，当m=1时，hm(1,a,b,c)=mv(a,c);3.可以把hm(m,a,b,c)进行细分为三步： 1&gt;先将n-1个圆盘从A通过C移动到B，此时b和c进行互换，也就是 hm(m-1,a,c,b); 2&gt;然后将剩下的最大的圆盘从A移动到C，也就是hm(1,a,b,c); 3&gt;最后将n-1个圆盘从B通过A移动到C，此时b和a进行交换，也就是 hm(m-1,b,a,c); 最终得到过程的递归关系式：hm(m,a,b,c) = hm(m-1,a,c,b)+1+hm(m-1,b,a,c); 代码：public class test{public static void main(String[] args){ Scanner in = new Scanner(System.in); int n = in.nextInt(); test t = new test(); //获取总的步数 System.out.println(“需要移动的总步数为:” +t.getSum(n)); //获取移动的过程 t.hm(n,’a’,’b’,’c’); } //获取总步数 public int getSum(int n){ if(n == 1) return 1; return 2 * getSum(n-1) +1 ; } //获取移动的过程 public void hm(int m,char a,char b,char c){ if(m == 1) move(a,c); hm(m-1,a,c,b); move(a,c); hm(m-1,b,a,c); } //输出一次移动的过程 public void move(char a,char c){ System.out.print(a + “–&gt;” + c + “ “); } }","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2019-10-13T10:01:23.000Z","updated":"2019-10-13T10:02:53.057Z","comments":true,"path":"2019/10/13/第一篇博客/","link":"","permalink":"http://yoursite.com/2019/10/13/第一篇博客/","excerpt":"","text":"Javaoop总结1.类与对象 抽象的，泛指的，是指从某一类具有相同属性和方法的对象中抽取出来 class代表类 类的作用；实例化对象，方法，工具类 类中分两大块：属性（成员变量） 方法（成员方法） 类如何实例化对象？ new Person p = new Person(); p.name = “张三”; p.sex = “男”; p：对象名 Person p1 = new Person();2. 属性与方法 方法的调用：对象名.方法名 匿名对象调用方法：new 类().方法名 new Person().getA(); int c = new Person().getD(10, 20); //实参 System.out.println(c);3.static static 静态，static用来修饰属性、方法 用static修饰属性：共有的属性——实例化出来的对象，用static修饰的具有相同的值。 用static修饰方法：能通过类名直接调用 4.封装, oopd三大特征之一； 属性私有化，公开setter和getter方法； 单例模式 只能实例化一次； 实现单例式的三个步骤：第一：私有化构造方法 private 类名（）{ } 第二：公开一个代理方法 private static 类名 方法名（）{ 类名 d=null； if（count&lt;1）{ d=new 类名（）； count++; } return d; } 第三：私有化一个静态属性，用来统计new的个数 private static int count=0; 5.继承,oop三大特征之一 继承 会让两个类产生一种关系 父类-子类 父类：从子类中抽取出共同的属性和共同的方法，放到父类中， 然后让子类继承父类，那子类就具有父类的属性和方法 继承的关键词：extends 类的继承格式 class 父类 { } class 子类 extends 父类 { } (1)父类中私有的属性和方法，子类是不能继承的 (2)父类的构造方法，子类是不能继承的 (3)父类是跨包的，除public以外的都不能被继承super 子类用来访问父类的方法或者属性 super.方法 super.属性 super()只能放在子类的构造方法中，并且只能放在第一行 重写 子类重写父类的方法； 方法名 +快捷键 多态,oop三大特征之一 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性多态存在的三个必要条件继承重写父类引用指向子类对象向上转型子类向父类的转换&lt;父类型&gt; &lt;引用变量名&gt;=new&lt;子类型&gt;;向下转型父类型转换为子类型&lt;子类型&gt;&lt;引用变量名&gt;=(&lt;子类型&gt;）&lt;父类型的引用变量&gt;; 抽象 (1)抽象 abstract abstract能修饰什么？类，方法(2) 用abstract修饰类叫抽象类 特点：抽象类不能被实例化，但能被继承 (3)用abstract修饰的方法叫抽象方法 特点：1.抽象方法没有方法体 2.抽象方法必须放在抽象类中，抽象类中的方法不一定是抽象方法 3.抽象类被子类继承后，那么子类要重写父类中的抽象方法，除非子类也是抽象类 访问权限private (私有的) 默认 (友好的) protected (受保护的) public (公共的) 9.final (1)final修饰类中的属性或者变量 无论属性是基本类型还是引用类型，final所起的作用都是变量里面存放的“值”不能变。 (2)final修饰类中的方法 作用：可以被继承，但继承后不能被重写。 (3)final修饰类 作用：类不可以被继承。 10.接口（重点） 创建接口类 public interface 接口的声明语法格式 interface 接口名称 extends 其他的接口名 { // 声明变量 // 抽象方法 } 接口关键字： interface 类要实现接口：implements class 类名 extends 父类名 implements 接口，接口，…{ //类成员 } 接口中的方法全是抽象方法 接口中的方法全部要公开public 接口不能被实例化 接口可以被多实现 接口中的属性全部是静态常量","categories":[],"tags":[]},{"title":"Readers are welcome to browse","slug":"Readers-are-welcome-to-browse","date":"2019-10-10T10:19:43.000Z","updated":"2019-10-10T10:20:41.888Z","comments":true,"path":"2019/10/10/Readers-are-welcome-to-browse/","link":"","permalink":"http://yoursite.com/2019/10/10/Readers-are-welcome-to-browse/","excerpt":"","text":"public class HelloWorld { /* 第一个Java程序 * 它将打印字符串 Hello World */ public static void main(String []args) { System.out.println(“Hello World”); // 打印 Hello World }}","categories":[],"tags":[]},{"title":"post title with whitespace","slug":"post-title-with-whitespace","date":"2019-10-10T07:03:54.000Z","updated":"2019-10-10T09:56:19.604Z","comments":true,"path":"2019/10/10/post-title-with-whitespace/","link":"","permalink":"http://yoursite.com/2019/10/10/post-title-with-whitespace/","excerpt":"","text":"python","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-10-09T13:21:42.052Z","updated":"2019-10-09T13:21:42.052Z","comments":true,"path":"2019/10/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}